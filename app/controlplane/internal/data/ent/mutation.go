// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/authz"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/biz"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/apitoken"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/casbackend"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/casmapping"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/integration"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/integrationattachment"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/membership"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/organization"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/orginvitation"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/predicate"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/referrer"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/robotaccount"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/user"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/workflow"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/workflowcontract"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/workflowcontractversion"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/workflowrun"
	"github.com/google/uuid"
	"github.com/secure-systems-lab/go-securesystemslib/dsse"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIToken                = "APIToken"
	TypeCASBackend              = "CASBackend"
	TypeCASMapping              = "CASMapping"
	TypeIntegration             = "Integration"
	TypeIntegrationAttachment   = "IntegrationAttachment"
	TypeMembership              = "Membership"
	TypeOrgInvitation           = "OrgInvitation"
	TypeOrganization            = "Organization"
	TypeReferrer                = "Referrer"
	TypeRobotAccount            = "RobotAccount"
	TypeUser                    = "User"
	TypeWorkflow                = "Workflow"
	TypeWorkflowContract        = "WorkflowContract"
	TypeWorkflowContractVersion = "WorkflowContractVersion"
	TypeWorkflowRun             = "WorkflowRun"
)

// APITokenMutation represents an operation that mutates the APIToken nodes in the graph.
type APITokenMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	description         *string
	created_at          *time.Time
	expires_at          *time.Time
	revoked_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *uuid.UUID
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*APIToken, error)
	predicates          []predicate.APIToken
}

var _ ent.Mutation = (*APITokenMutation)(nil)

// apitokenOption allows management of the mutation configuration using functional options.
type apitokenOption func(*APITokenMutation)

// newAPITokenMutation creates new mutation for the APIToken entity.
func newAPITokenMutation(c config, op Op, opts ...apitokenOption) *APITokenMutation {
	m := &APITokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPITokenID sets the ID field of the mutation.
func withAPITokenID(id uuid.UUID) apitokenOption {
	return func(m *APITokenMutation) {
		var (
			err   error
			once  sync.Once
			value *APIToken
		)
		m.oldValue = func(ctx context.Context) (*APIToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIToken sets the old APIToken of the mutation.
func withAPIToken(node *APIToken) apitokenOption {
	return func(m *APITokenMutation) {
		m.oldValue = func(context.Context) (*APIToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APITokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APITokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of APIToken entities.
func (m *APITokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APITokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APITokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *APITokenMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APITokenMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *APITokenMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[apitoken.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *APITokenMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *APITokenMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, apitoken.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *APITokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APITokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APITokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *APITokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APITokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APITokenMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apitoken.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APITokenMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APITokenMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apitoken.FieldExpiresAt)
}

// SetRevokedAt sets the "revoked_at" field.
func (m *APITokenMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *APITokenMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldRevokedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *APITokenMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[apitoken.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *APITokenMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *APITokenMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, apitoken.FieldRevokedAt)
}

// SetOrganizationID sets the "organization_id" field.
func (m *APITokenMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *APITokenMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *APITokenMutation) ResetOrganizationID() {
	m.organization = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *APITokenMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *APITokenMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *APITokenMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *APITokenMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the APITokenMutation builder.
func (m *APITokenMutation) Where(ps ...predicate.APIToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APITokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APITokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APITokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APITokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIToken).
func (m *APITokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APITokenMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.description != nil {
		fields = append(fields, apitoken.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, apitoken.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, apitoken.FieldExpiresAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, apitoken.FieldRevokedAt)
	}
	if m.organization != nil {
		fields = append(fields, apitoken.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APITokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldDescription:
		return m.Description()
	case apitoken.FieldCreatedAt:
		return m.CreatedAt()
	case apitoken.FieldExpiresAt:
		return m.ExpiresAt()
	case apitoken.FieldRevokedAt:
		return m.RevokedAt()
	case apitoken.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APITokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitoken.FieldDescription:
		return m.OldDescription(ctx)
	case apitoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apitoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apitoken.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case apitoken.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown APIToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APITokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case apitoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apitoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apitoken.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case apitoken.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown APIToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APITokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APITokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APITokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown APIToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APITokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apitoken.FieldDescription) {
		fields = append(fields, apitoken.FieldDescription)
	}
	if m.FieldCleared(apitoken.FieldExpiresAt) {
		fields = append(fields, apitoken.FieldExpiresAt)
	}
	if m.FieldCleared(apitoken.FieldRevokedAt) {
		fields = append(fields, apitoken.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APITokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APITokenMutation) ClearField(name string) error {
	switch name {
	case apitoken.FieldDescription:
		m.ClearDescription()
		return nil
	case apitoken.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case apitoken.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown APIToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APITokenMutation) ResetField(name string) error {
	switch name {
	case apitoken.FieldDescription:
		m.ResetDescription()
		return nil
	case apitoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apitoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apitoken.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case apitoken.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown APIToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APITokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, apitoken.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APITokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APITokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APITokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APITokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, apitoken.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APITokenMutation) EdgeCleared(name string) bool {
	switch name {
	case apitoken.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APITokenMutation) ClearEdge(name string) error {
	switch name {
	case apitoken.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown APIToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APITokenMutation) ResetEdge(name string) error {
	switch name {
	case apitoken.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown APIToken edge %s", name)
}

// CASBackendMutation represents an operation that mutates the CASBackend nodes in the graph.
type CASBackendMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	location            *string
	provider            *biz.CASBackendProvider
	description         *string
	secret_name         *string
	created_at          *time.Time
	validation_status   *biz.CASBackendValidationStatus
	validated_at        *time.Time
	_default            *bool
	deleted_at          *time.Time
	fallback            *bool
	clearedFields       map[string]struct{}
	organization        *uuid.UUID
	clearedorganization bool
	workflow_run        map[uuid.UUID]struct{}
	removedworkflow_run map[uuid.UUID]struct{}
	clearedworkflow_run bool
	done                bool
	oldValue            func(context.Context) (*CASBackend, error)
	predicates          []predicate.CASBackend
}

var _ ent.Mutation = (*CASBackendMutation)(nil)

// casbackendOption allows management of the mutation configuration using functional options.
type casbackendOption func(*CASBackendMutation)

// newCASBackendMutation creates new mutation for the CASBackend entity.
func newCASBackendMutation(c config, op Op, opts ...casbackendOption) *CASBackendMutation {
	m := &CASBackendMutation{
		config:        c,
		op:            op,
		typ:           TypeCASBackend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCASBackendID sets the ID field of the mutation.
func withCASBackendID(id uuid.UUID) casbackendOption {
	return func(m *CASBackendMutation) {
		var (
			err   error
			once  sync.Once
			value *CASBackend
		)
		m.oldValue = func(ctx context.Context) (*CASBackend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CASBackend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCASBackend sets the old CASBackend of the mutation.
func withCASBackend(node *CASBackend) casbackendOption {
	return func(m *CASBackendMutation) {
		m.oldValue = func(context.Context) (*CASBackend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CASBackendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CASBackendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CASBackend entities.
func (m *CASBackendMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CASBackendMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CASBackendMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CASBackend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLocation sets the "location" field.
func (m *CASBackendMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *CASBackendMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *CASBackendMutation) ResetLocation() {
	m.location = nil
}

// SetProvider sets the "provider" field.
func (m *CASBackendMutation) SetProvider(bbp biz.CASBackendProvider) {
	m.provider = &bbp
}

// Provider returns the value of the "provider" field in the mutation.
func (m *CASBackendMutation) Provider() (r biz.CASBackendProvider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldProvider(ctx context.Context) (v biz.CASBackendProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *CASBackendMutation) ResetProvider() {
	m.provider = nil
}

// SetDescription sets the "description" field.
func (m *CASBackendMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CASBackendMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CASBackendMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[casbackend.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CASBackendMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[casbackend.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CASBackendMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, casbackend.FieldDescription)
}

// SetSecretName sets the "secret_name" field.
func (m *CASBackendMutation) SetSecretName(s string) {
	m.secret_name = &s
}

// SecretName returns the value of the "secret_name" field in the mutation.
func (m *CASBackendMutation) SecretName() (r string, exists bool) {
	v := m.secret_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretName returns the old "secret_name" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldSecretName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretName: %w", err)
	}
	return oldValue.SecretName, nil
}

// ResetSecretName resets all changes to the "secret_name" field.
func (m *CASBackendMutation) ResetSecretName() {
	m.secret_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CASBackendMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CASBackendMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CASBackendMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetValidationStatus sets the "validation_status" field.
func (m *CASBackendMutation) SetValidationStatus(bbvs biz.CASBackendValidationStatus) {
	m.validation_status = &bbvs
}

// ValidationStatus returns the value of the "validation_status" field in the mutation.
func (m *CASBackendMutation) ValidationStatus() (r biz.CASBackendValidationStatus, exists bool) {
	v := m.validation_status
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationStatus returns the old "validation_status" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldValidationStatus(ctx context.Context) (v biz.CASBackendValidationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationStatus: %w", err)
	}
	return oldValue.ValidationStatus, nil
}

// ResetValidationStatus resets all changes to the "validation_status" field.
func (m *CASBackendMutation) ResetValidationStatus() {
	m.validation_status = nil
}

// SetValidatedAt sets the "validated_at" field.
func (m *CASBackendMutation) SetValidatedAt(t time.Time) {
	m.validated_at = &t
}

// ValidatedAt returns the value of the "validated_at" field in the mutation.
func (m *CASBackendMutation) ValidatedAt() (r time.Time, exists bool) {
	v := m.validated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldValidatedAt returns the old "validated_at" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldValidatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidatedAt: %w", err)
	}
	return oldValue.ValidatedAt, nil
}

// ResetValidatedAt resets all changes to the "validated_at" field.
func (m *CASBackendMutation) ResetValidatedAt() {
	m.validated_at = nil
}

// SetDefault sets the "default" field.
func (m *CASBackendMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *CASBackendMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *CASBackendMutation) ResetDefault() {
	m._default = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CASBackendMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CASBackendMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CASBackendMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[casbackend.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CASBackendMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[casbackend.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CASBackendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, casbackend.FieldDeletedAt)
}

// SetFallback sets the "fallback" field.
func (m *CASBackendMutation) SetFallback(b bool) {
	m.fallback = &b
}

// Fallback returns the value of the "fallback" field in the mutation.
func (m *CASBackendMutation) Fallback() (r bool, exists bool) {
	v := m.fallback
	if v == nil {
		return
	}
	return *v, true
}

// OldFallback returns the old "fallback" field's value of the CASBackend entity.
// If the CASBackend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASBackendMutation) OldFallback(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFallback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFallback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFallback: %w", err)
	}
	return oldValue.Fallback, nil
}

// ResetFallback resets all changes to the "fallback" field.
func (m *CASBackendMutation) ResetFallback() {
	m.fallback = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *CASBackendMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CASBackendMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CASBackendMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *CASBackendMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CASBackendMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CASBackendMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddWorkflowRunIDs adds the "workflow_run" edge to the WorkflowRun entity by ids.
func (m *CASBackendMutation) AddWorkflowRunIDs(ids ...uuid.UUID) {
	if m.workflow_run == nil {
		m.workflow_run = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflow_run[ids[i]] = struct{}{}
	}
}

// ClearWorkflowRun clears the "workflow_run" edge to the WorkflowRun entity.
func (m *CASBackendMutation) ClearWorkflowRun() {
	m.clearedworkflow_run = true
}

// WorkflowRunCleared reports if the "workflow_run" edge to the WorkflowRun entity was cleared.
func (m *CASBackendMutation) WorkflowRunCleared() bool {
	return m.clearedworkflow_run
}

// RemoveWorkflowRunIDs removes the "workflow_run" edge to the WorkflowRun entity by IDs.
func (m *CASBackendMutation) RemoveWorkflowRunIDs(ids ...uuid.UUID) {
	if m.removedworkflow_run == nil {
		m.removedworkflow_run = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflow_run, ids[i])
		m.removedworkflow_run[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowRun returns the removed IDs of the "workflow_run" edge to the WorkflowRun entity.
func (m *CASBackendMutation) RemovedWorkflowRunIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflow_run {
		ids = append(ids, id)
	}
	return
}

// WorkflowRunIDs returns the "workflow_run" edge IDs in the mutation.
func (m *CASBackendMutation) WorkflowRunIDs() (ids []uuid.UUID) {
	for id := range m.workflow_run {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowRun resets all changes to the "workflow_run" edge.
func (m *CASBackendMutation) ResetWorkflowRun() {
	m.workflow_run = nil
	m.clearedworkflow_run = false
	m.removedworkflow_run = nil
}

// Where appends a list predicates to the CASBackendMutation builder.
func (m *CASBackendMutation) Where(ps ...predicate.CASBackend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CASBackendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CASBackendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CASBackend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CASBackendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CASBackendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CASBackend).
func (m *CASBackendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CASBackendMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.location != nil {
		fields = append(fields, casbackend.FieldLocation)
	}
	if m.provider != nil {
		fields = append(fields, casbackend.FieldProvider)
	}
	if m.description != nil {
		fields = append(fields, casbackend.FieldDescription)
	}
	if m.secret_name != nil {
		fields = append(fields, casbackend.FieldSecretName)
	}
	if m.created_at != nil {
		fields = append(fields, casbackend.FieldCreatedAt)
	}
	if m.validation_status != nil {
		fields = append(fields, casbackend.FieldValidationStatus)
	}
	if m.validated_at != nil {
		fields = append(fields, casbackend.FieldValidatedAt)
	}
	if m._default != nil {
		fields = append(fields, casbackend.FieldDefault)
	}
	if m.deleted_at != nil {
		fields = append(fields, casbackend.FieldDeletedAt)
	}
	if m.fallback != nil {
		fields = append(fields, casbackend.FieldFallback)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CASBackendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case casbackend.FieldLocation:
		return m.Location()
	case casbackend.FieldProvider:
		return m.Provider()
	case casbackend.FieldDescription:
		return m.Description()
	case casbackend.FieldSecretName:
		return m.SecretName()
	case casbackend.FieldCreatedAt:
		return m.CreatedAt()
	case casbackend.FieldValidationStatus:
		return m.ValidationStatus()
	case casbackend.FieldValidatedAt:
		return m.ValidatedAt()
	case casbackend.FieldDefault:
		return m.Default()
	case casbackend.FieldDeletedAt:
		return m.DeletedAt()
	case casbackend.FieldFallback:
		return m.Fallback()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CASBackendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case casbackend.FieldLocation:
		return m.OldLocation(ctx)
	case casbackend.FieldProvider:
		return m.OldProvider(ctx)
	case casbackend.FieldDescription:
		return m.OldDescription(ctx)
	case casbackend.FieldSecretName:
		return m.OldSecretName(ctx)
	case casbackend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case casbackend.FieldValidationStatus:
		return m.OldValidationStatus(ctx)
	case casbackend.FieldValidatedAt:
		return m.OldValidatedAt(ctx)
	case casbackend.FieldDefault:
		return m.OldDefault(ctx)
	case casbackend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case casbackend.FieldFallback:
		return m.OldFallback(ctx)
	}
	return nil, fmt.Errorf("unknown CASBackend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CASBackendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case casbackend.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case casbackend.FieldProvider:
		v, ok := value.(biz.CASBackendProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case casbackend.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case casbackend.FieldSecretName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretName(v)
		return nil
	case casbackend.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case casbackend.FieldValidationStatus:
		v, ok := value.(biz.CASBackendValidationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationStatus(v)
		return nil
	case casbackend.FieldValidatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidatedAt(v)
		return nil
	case casbackend.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	case casbackend.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case casbackend.FieldFallback:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFallback(v)
		return nil
	}
	return fmt.Errorf("unknown CASBackend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CASBackendMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CASBackendMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CASBackendMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CASBackend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CASBackendMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(casbackend.FieldDescription) {
		fields = append(fields, casbackend.FieldDescription)
	}
	if m.FieldCleared(casbackend.FieldDeletedAt) {
		fields = append(fields, casbackend.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CASBackendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CASBackendMutation) ClearField(name string) error {
	switch name {
	case casbackend.FieldDescription:
		m.ClearDescription()
		return nil
	case casbackend.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CASBackend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CASBackendMutation) ResetField(name string) error {
	switch name {
	case casbackend.FieldLocation:
		m.ResetLocation()
		return nil
	case casbackend.FieldProvider:
		m.ResetProvider()
		return nil
	case casbackend.FieldDescription:
		m.ResetDescription()
		return nil
	case casbackend.FieldSecretName:
		m.ResetSecretName()
		return nil
	case casbackend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case casbackend.FieldValidationStatus:
		m.ResetValidationStatus()
		return nil
	case casbackend.FieldValidatedAt:
		m.ResetValidatedAt()
		return nil
	case casbackend.FieldDefault:
		m.ResetDefault()
		return nil
	case casbackend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case casbackend.FieldFallback:
		m.ResetFallback()
		return nil
	}
	return fmt.Errorf("unknown CASBackend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CASBackendMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, casbackend.EdgeOrganization)
	}
	if m.workflow_run != nil {
		edges = append(edges, casbackend.EdgeWorkflowRun)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CASBackendMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case casbackend.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case casbackend.EdgeWorkflowRun:
		ids := make([]ent.Value, 0, len(m.workflow_run))
		for id := range m.workflow_run {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CASBackendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedworkflow_run != nil {
		edges = append(edges, casbackend.EdgeWorkflowRun)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CASBackendMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case casbackend.EdgeWorkflowRun:
		ids := make([]ent.Value, 0, len(m.removedworkflow_run))
		for id := range m.removedworkflow_run {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CASBackendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, casbackend.EdgeOrganization)
	}
	if m.clearedworkflow_run {
		edges = append(edges, casbackend.EdgeWorkflowRun)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CASBackendMutation) EdgeCleared(name string) bool {
	switch name {
	case casbackend.EdgeOrganization:
		return m.clearedorganization
	case casbackend.EdgeWorkflowRun:
		return m.clearedworkflow_run
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CASBackendMutation) ClearEdge(name string) error {
	switch name {
	case casbackend.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown CASBackend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CASBackendMutation) ResetEdge(name string) error {
	switch name {
	case casbackend.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case casbackend.EdgeWorkflowRun:
		m.ResetWorkflowRun()
		return nil
	}
	return fmt.Errorf("unknown CASBackend edge %s", name)
}

// CASMappingMutation represents an operation that mutates the CASMapping nodes in the graph.
type CASMappingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	digest              *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	cas_backend         *uuid.UUID
	clearedcas_backend  bool
	workflow_run        *uuid.UUID
	clearedworkflow_run bool
	organization        *uuid.UUID
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*CASMapping, error)
	predicates          []predicate.CASMapping
}

var _ ent.Mutation = (*CASMappingMutation)(nil)

// casmappingOption allows management of the mutation configuration using functional options.
type casmappingOption func(*CASMappingMutation)

// newCASMappingMutation creates new mutation for the CASMapping entity.
func newCASMappingMutation(c config, op Op, opts ...casmappingOption) *CASMappingMutation {
	m := &CASMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeCASMapping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCASMappingID sets the ID field of the mutation.
func withCASMappingID(id uuid.UUID) casmappingOption {
	return func(m *CASMappingMutation) {
		var (
			err   error
			once  sync.Once
			value *CASMapping
		)
		m.oldValue = func(ctx context.Context) (*CASMapping, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CASMapping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCASMapping sets the old CASMapping of the mutation.
func withCASMapping(node *CASMapping) casmappingOption {
	return func(m *CASMappingMutation) {
		m.oldValue = func(context.Context) (*CASMapping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CASMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CASMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CASMapping entities.
func (m *CASMappingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CASMappingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CASMappingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CASMapping.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDigest sets the "digest" field.
func (m *CASMappingMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *CASMappingMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the CASMapping entity.
// If the CASMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASMappingMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ResetDigest resets all changes to the "digest" field.
func (m *CASMappingMutation) ResetDigest() {
	m.digest = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CASMappingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CASMappingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CASMapping entity.
// If the CASMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CASMappingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CASMappingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCasBackendID sets the "cas_backend" edge to the CASBackend entity by id.
func (m *CASMappingMutation) SetCasBackendID(id uuid.UUID) {
	m.cas_backend = &id
}

// ClearCasBackend clears the "cas_backend" edge to the CASBackend entity.
func (m *CASMappingMutation) ClearCasBackend() {
	m.clearedcas_backend = true
}

// CasBackendCleared reports if the "cas_backend" edge to the CASBackend entity was cleared.
func (m *CASMappingMutation) CasBackendCleared() bool {
	return m.clearedcas_backend
}

// CasBackendID returns the "cas_backend" edge ID in the mutation.
func (m *CASMappingMutation) CasBackendID() (id uuid.UUID, exists bool) {
	if m.cas_backend != nil {
		return *m.cas_backend, true
	}
	return
}

// CasBackendIDs returns the "cas_backend" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CasBackendID instead. It exists only for internal usage by the builders.
func (m *CASMappingMutation) CasBackendIDs() (ids []uuid.UUID) {
	if id := m.cas_backend; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCasBackend resets all changes to the "cas_backend" edge.
func (m *CASMappingMutation) ResetCasBackend() {
	m.cas_backend = nil
	m.clearedcas_backend = false
}

// SetWorkflowRunID sets the "workflow_run" edge to the WorkflowRun entity by id.
func (m *CASMappingMutation) SetWorkflowRunID(id uuid.UUID) {
	m.workflow_run = &id
}

// ClearWorkflowRun clears the "workflow_run" edge to the WorkflowRun entity.
func (m *CASMappingMutation) ClearWorkflowRun() {
	m.clearedworkflow_run = true
}

// WorkflowRunCleared reports if the "workflow_run" edge to the WorkflowRun entity was cleared.
func (m *CASMappingMutation) WorkflowRunCleared() bool {
	return m.clearedworkflow_run
}

// WorkflowRunID returns the "workflow_run" edge ID in the mutation.
func (m *CASMappingMutation) WorkflowRunID() (id uuid.UUID, exists bool) {
	if m.workflow_run != nil {
		return *m.workflow_run, true
	}
	return
}

// WorkflowRunIDs returns the "workflow_run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowRunID instead. It exists only for internal usage by the builders.
func (m *CASMappingMutation) WorkflowRunIDs() (ids []uuid.UUID) {
	if id := m.workflow_run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowRun resets all changes to the "workflow_run" edge.
func (m *CASMappingMutation) ResetWorkflowRun() {
	m.workflow_run = nil
	m.clearedworkflow_run = false
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *CASMappingMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CASMappingMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CASMappingMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *CASMappingMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CASMappingMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CASMappingMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the CASMappingMutation builder.
func (m *CASMappingMutation) Where(ps ...predicate.CASMapping) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CASMappingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CASMappingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CASMapping, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CASMappingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CASMappingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CASMapping).
func (m *CASMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CASMappingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.digest != nil {
		fields = append(fields, casmapping.FieldDigest)
	}
	if m.created_at != nil {
		fields = append(fields, casmapping.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CASMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case casmapping.FieldDigest:
		return m.Digest()
	case casmapping.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CASMappingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case casmapping.FieldDigest:
		return m.OldDigest(ctx)
	case casmapping.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CASMapping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CASMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case casmapping.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	case casmapping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CASMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CASMappingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CASMappingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CASMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CASMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CASMappingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CASMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CASMappingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CASMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CASMappingMutation) ResetField(name string) error {
	switch name {
	case casmapping.FieldDigest:
		m.ResetDigest()
		return nil
	case casmapping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown CASMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CASMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cas_backend != nil {
		edges = append(edges, casmapping.EdgeCasBackend)
	}
	if m.workflow_run != nil {
		edges = append(edges, casmapping.EdgeWorkflowRun)
	}
	if m.organization != nil {
		edges = append(edges, casmapping.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CASMappingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case casmapping.EdgeCasBackend:
		if id := m.cas_backend; id != nil {
			return []ent.Value{*id}
		}
	case casmapping.EdgeWorkflowRun:
		if id := m.workflow_run; id != nil {
			return []ent.Value{*id}
		}
	case casmapping.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CASMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CASMappingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CASMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcas_backend {
		edges = append(edges, casmapping.EdgeCasBackend)
	}
	if m.clearedworkflow_run {
		edges = append(edges, casmapping.EdgeWorkflowRun)
	}
	if m.clearedorganization {
		edges = append(edges, casmapping.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CASMappingMutation) EdgeCleared(name string) bool {
	switch name {
	case casmapping.EdgeCasBackend:
		return m.clearedcas_backend
	case casmapping.EdgeWorkflowRun:
		return m.clearedworkflow_run
	case casmapping.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CASMappingMutation) ClearEdge(name string) error {
	switch name {
	case casmapping.EdgeCasBackend:
		m.ClearCasBackend()
		return nil
	case casmapping.EdgeWorkflowRun:
		m.ClearWorkflowRun()
		return nil
	case casmapping.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown CASMapping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CASMappingMutation) ResetEdge(name string) error {
	switch name {
	case casmapping.EdgeCasBackend:
		m.ResetCasBackend()
		return nil
	case casmapping.EdgeWorkflowRun:
		m.ResetWorkflowRun()
		return nil
	case casmapping.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown CASMapping edge %s", name)
}

// IntegrationMutation represents an operation that mutates the Integration nodes in the graph.
type IntegrationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	kind                *string
	description         *string
	secret_name         *string
	created_at          *time.Time
	configuration       *[]byte
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	attachments         map[uuid.UUID]struct{}
	removedattachments  map[uuid.UUID]struct{}
	clearedattachments  bool
	organization        *uuid.UUID
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*Integration, error)
	predicates          []predicate.Integration
}

var _ ent.Mutation = (*IntegrationMutation)(nil)

// integrationOption allows management of the mutation configuration using functional options.
type integrationOption func(*IntegrationMutation)

// newIntegrationMutation creates new mutation for the Integration entity.
func newIntegrationMutation(c config, op Op, opts ...integrationOption) *IntegrationMutation {
	m := &IntegrationMutation{
		config:        c,
		op:            op,
		typ:           TypeIntegration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIntegrationID sets the ID field of the mutation.
func withIntegrationID(id uuid.UUID) integrationOption {
	return func(m *IntegrationMutation) {
		var (
			err   error
			once  sync.Once
			value *Integration
		)
		m.oldValue = func(ctx context.Context) (*Integration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Integration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIntegration sets the old Integration of the mutation.
func withIntegration(node *Integration) integrationOption {
	return func(m *IntegrationMutation) {
		m.oldValue = func(context.Context) (*Integration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IntegrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IntegrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Integration entities.
func (m *IntegrationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IntegrationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IntegrationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Integration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKind sets the "kind" field.
func (m *IntegrationMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *IntegrationMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *IntegrationMutation) ResetKind() {
	m.kind = nil
}

// SetDescription sets the "description" field.
func (m *IntegrationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IntegrationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IntegrationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[integration.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IntegrationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[integration.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IntegrationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, integration.FieldDescription)
}

// SetSecretName sets the "secret_name" field.
func (m *IntegrationMutation) SetSecretName(s string) {
	m.secret_name = &s
}

// SecretName returns the value of the "secret_name" field in the mutation.
func (m *IntegrationMutation) SecretName() (r string, exists bool) {
	v := m.secret_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretName returns the old "secret_name" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldSecretName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretName: %w", err)
	}
	return oldValue.SecretName, nil
}

// ResetSecretName resets all changes to the "secret_name" field.
func (m *IntegrationMutation) ResetSecretName() {
	m.secret_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IntegrationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IntegrationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IntegrationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConfiguration sets the "configuration" field.
func (m *IntegrationMutation) SetConfiguration(b []byte) {
	m.configuration = &b
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *IntegrationMutation) Configuration() (r []byte, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldConfiguration(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// ClearConfiguration clears the value of the "configuration" field.
func (m *IntegrationMutation) ClearConfiguration() {
	m.configuration = nil
	m.clearedFields[integration.FieldConfiguration] = struct{}{}
}

// ConfigurationCleared returns if the "configuration" field was cleared in this mutation.
func (m *IntegrationMutation) ConfigurationCleared() bool {
	_, ok := m.clearedFields[integration.FieldConfiguration]
	return ok
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *IntegrationMutation) ResetConfiguration() {
	m.configuration = nil
	delete(m.clearedFields, integration.FieldConfiguration)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IntegrationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IntegrationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IntegrationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[integration.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IntegrationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[integration.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IntegrationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, integration.FieldDeletedAt)
}

// AddAttachmentIDs adds the "attachments" edge to the IntegrationAttachment entity by ids.
func (m *IntegrationMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the IntegrationAttachment entity.
func (m *IntegrationMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the IntegrationAttachment entity was cleared.
func (m *IntegrationMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the IntegrationAttachment entity by IDs.
func (m *IntegrationMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the IntegrationAttachment entity.
func (m *IntegrationMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *IntegrationMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *IntegrationMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *IntegrationMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *IntegrationMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *IntegrationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *IntegrationMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *IntegrationMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *IntegrationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the IntegrationMutation builder.
func (m *IntegrationMutation) Where(ps ...predicate.Integration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IntegrationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IntegrationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Integration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IntegrationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IntegrationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Integration).
func (m *IntegrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IntegrationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.kind != nil {
		fields = append(fields, integration.FieldKind)
	}
	if m.description != nil {
		fields = append(fields, integration.FieldDescription)
	}
	if m.secret_name != nil {
		fields = append(fields, integration.FieldSecretName)
	}
	if m.created_at != nil {
		fields = append(fields, integration.FieldCreatedAt)
	}
	if m.configuration != nil {
		fields = append(fields, integration.FieldConfiguration)
	}
	if m.deleted_at != nil {
		fields = append(fields, integration.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IntegrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case integration.FieldKind:
		return m.Kind()
	case integration.FieldDescription:
		return m.Description()
	case integration.FieldSecretName:
		return m.SecretName()
	case integration.FieldCreatedAt:
		return m.CreatedAt()
	case integration.FieldConfiguration:
		return m.Configuration()
	case integration.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IntegrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case integration.FieldKind:
		return m.OldKind(ctx)
	case integration.FieldDescription:
		return m.OldDescription(ctx)
	case integration.FieldSecretName:
		return m.OldSecretName(ctx)
	case integration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case integration.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case integration.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Integration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case integration.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case integration.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case integration.FieldSecretName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretName(v)
		return nil
	case integration.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case integration.FieldConfiguration:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case integration.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Integration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IntegrationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IntegrationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Integration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IntegrationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(integration.FieldDescription) {
		fields = append(fields, integration.FieldDescription)
	}
	if m.FieldCleared(integration.FieldConfiguration) {
		fields = append(fields, integration.FieldConfiguration)
	}
	if m.FieldCleared(integration.FieldDeletedAt) {
		fields = append(fields, integration.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IntegrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IntegrationMutation) ClearField(name string) error {
	switch name {
	case integration.FieldDescription:
		m.ClearDescription()
		return nil
	case integration.FieldConfiguration:
		m.ClearConfiguration()
		return nil
	case integration.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Integration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IntegrationMutation) ResetField(name string) error {
	switch name {
	case integration.FieldKind:
		m.ResetKind()
		return nil
	case integration.FieldDescription:
		m.ResetDescription()
		return nil
	case integration.FieldSecretName:
		m.ResetSecretName()
		return nil
	case integration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case integration.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case integration.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Integration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IntegrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attachments != nil {
		edges = append(edges, integration.EdgeAttachments)
	}
	if m.organization != nil {
		edges = append(edges, integration.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IntegrationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case integration.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case integration.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IntegrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedattachments != nil {
		edges = append(edges, integration.EdgeAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IntegrationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case integration.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IntegrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattachments {
		edges = append(edges, integration.EdgeAttachments)
	}
	if m.clearedorganization {
		edges = append(edges, integration.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IntegrationMutation) EdgeCleared(name string) bool {
	switch name {
	case integration.EdgeAttachments:
		return m.clearedattachments
	case integration.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IntegrationMutation) ClearEdge(name string) error {
	switch name {
	case integration.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Integration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IntegrationMutation) ResetEdge(name string) error {
	switch name {
	case integration.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case integration.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown Integration edge %s", name)
}

// IntegrationAttachmentMutation represents an operation that mutates the IntegrationAttachment nodes in the graph.
type IntegrationAttachmentMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	configuration      *[]byte
	deleted_at         *time.Time
	clearedFields      map[string]struct{}
	integration        *uuid.UUID
	clearedintegration bool
	workflow           *uuid.UUID
	clearedworkflow    bool
	done               bool
	oldValue           func(context.Context) (*IntegrationAttachment, error)
	predicates         []predicate.IntegrationAttachment
}

var _ ent.Mutation = (*IntegrationAttachmentMutation)(nil)

// integrationattachmentOption allows management of the mutation configuration using functional options.
type integrationattachmentOption func(*IntegrationAttachmentMutation)

// newIntegrationAttachmentMutation creates new mutation for the IntegrationAttachment entity.
func newIntegrationAttachmentMutation(c config, op Op, opts ...integrationattachmentOption) *IntegrationAttachmentMutation {
	m := &IntegrationAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeIntegrationAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIntegrationAttachmentID sets the ID field of the mutation.
func withIntegrationAttachmentID(id uuid.UUID) integrationattachmentOption {
	return func(m *IntegrationAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *IntegrationAttachment
		)
		m.oldValue = func(ctx context.Context) (*IntegrationAttachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IntegrationAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIntegrationAttachment sets the old IntegrationAttachment of the mutation.
func withIntegrationAttachment(node *IntegrationAttachment) integrationattachmentOption {
	return func(m *IntegrationAttachmentMutation) {
		m.oldValue = func(context.Context) (*IntegrationAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IntegrationAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IntegrationAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IntegrationAttachment entities.
func (m *IntegrationAttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IntegrationAttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IntegrationAttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IntegrationAttachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IntegrationAttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IntegrationAttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IntegrationAttachment entity.
// If the IntegrationAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationAttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IntegrationAttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConfiguration sets the "configuration" field.
func (m *IntegrationAttachmentMutation) SetConfiguration(b []byte) {
	m.configuration = &b
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *IntegrationAttachmentMutation) Configuration() (r []byte, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the IntegrationAttachment entity.
// If the IntegrationAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationAttachmentMutation) OldConfiguration(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// ClearConfiguration clears the value of the "configuration" field.
func (m *IntegrationAttachmentMutation) ClearConfiguration() {
	m.configuration = nil
	m.clearedFields[integrationattachment.FieldConfiguration] = struct{}{}
}

// ConfigurationCleared returns if the "configuration" field was cleared in this mutation.
func (m *IntegrationAttachmentMutation) ConfigurationCleared() bool {
	_, ok := m.clearedFields[integrationattachment.FieldConfiguration]
	return ok
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *IntegrationAttachmentMutation) ResetConfiguration() {
	m.configuration = nil
	delete(m.clearedFields, integrationattachment.FieldConfiguration)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IntegrationAttachmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IntegrationAttachmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IntegrationAttachment entity.
// If the IntegrationAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationAttachmentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IntegrationAttachmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[integrationattachment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IntegrationAttachmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[integrationattachment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IntegrationAttachmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, integrationattachment.FieldDeletedAt)
}

// SetIntegrationID sets the "integration" edge to the Integration entity by id.
func (m *IntegrationAttachmentMutation) SetIntegrationID(id uuid.UUID) {
	m.integration = &id
}

// ClearIntegration clears the "integration" edge to the Integration entity.
func (m *IntegrationAttachmentMutation) ClearIntegration() {
	m.clearedintegration = true
}

// IntegrationCleared reports if the "integration" edge to the Integration entity was cleared.
func (m *IntegrationAttachmentMutation) IntegrationCleared() bool {
	return m.clearedintegration
}

// IntegrationID returns the "integration" edge ID in the mutation.
func (m *IntegrationAttachmentMutation) IntegrationID() (id uuid.UUID, exists bool) {
	if m.integration != nil {
		return *m.integration, true
	}
	return
}

// IntegrationIDs returns the "integration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IntegrationID instead. It exists only for internal usage by the builders.
func (m *IntegrationAttachmentMutation) IntegrationIDs() (ids []uuid.UUID) {
	if id := m.integration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIntegration resets all changes to the "integration" edge.
func (m *IntegrationAttachmentMutation) ResetIntegration() {
	m.integration = nil
	m.clearedintegration = false
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *IntegrationAttachmentMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *IntegrationAttachmentMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *IntegrationAttachmentMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *IntegrationAttachmentMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *IntegrationAttachmentMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *IntegrationAttachmentMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the IntegrationAttachmentMutation builder.
func (m *IntegrationAttachmentMutation) Where(ps ...predicate.IntegrationAttachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IntegrationAttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IntegrationAttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IntegrationAttachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IntegrationAttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IntegrationAttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IntegrationAttachment).
func (m *IntegrationAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IntegrationAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, integrationattachment.FieldCreatedAt)
	}
	if m.configuration != nil {
		fields = append(fields, integrationattachment.FieldConfiguration)
	}
	if m.deleted_at != nil {
		fields = append(fields, integrationattachment.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IntegrationAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case integrationattachment.FieldCreatedAt:
		return m.CreatedAt()
	case integrationattachment.FieldConfiguration:
		return m.Configuration()
	case integrationattachment.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IntegrationAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case integrationattachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case integrationattachment.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case integrationattachment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IntegrationAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case integrationattachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case integrationattachment.FieldConfiguration:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case integrationattachment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IntegrationAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IntegrationAttachmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IntegrationAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IntegrationAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IntegrationAttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(integrationattachment.FieldConfiguration) {
		fields = append(fields, integrationattachment.FieldConfiguration)
	}
	if m.FieldCleared(integrationattachment.FieldDeletedAt) {
		fields = append(fields, integrationattachment.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IntegrationAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IntegrationAttachmentMutation) ClearField(name string) error {
	switch name {
	case integrationattachment.FieldConfiguration:
		m.ClearConfiguration()
		return nil
	case integrationattachment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown IntegrationAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IntegrationAttachmentMutation) ResetField(name string) error {
	switch name {
	case integrationattachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case integrationattachment.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case integrationattachment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown IntegrationAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IntegrationAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.integration != nil {
		edges = append(edges, integrationattachment.EdgeIntegration)
	}
	if m.workflow != nil {
		edges = append(edges, integrationattachment.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IntegrationAttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case integrationattachment.EdgeIntegration:
		if id := m.integration; id != nil {
			return []ent.Value{*id}
		}
	case integrationattachment.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IntegrationAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IntegrationAttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IntegrationAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedintegration {
		edges = append(edges, integrationattachment.EdgeIntegration)
	}
	if m.clearedworkflow {
		edges = append(edges, integrationattachment.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IntegrationAttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case integrationattachment.EdgeIntegration:
		return m.clearedintegration
	case integrationattachment.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IntegrationAttachmentMutation) ClearEdge(name string) error {
	switch name {
	case integrationattachment.EdgeIntegration:
		m.ClearIntegration()
		return nil
	case integrationattachment.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown IntegrationAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IntegrationAttachmentMutation) ResetEdge(name string) error {
	switch name {
	case integrationattachment.EdgeIntegration:
		m.ResetIntegration()
		return nil
	case integrationattachment.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown IntegrationAttachment edge %s", name)
}

// MembershipMutation represents an operation that mutates the Membership nodes in the graph.
type MembershipMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	current             *bool
	created_at          *time.Time
	updated_at          *time.Time
	role                *authz.Role
	clearedFields       map[string]struct{}
	organization        *uuid.UUID
	clearedorganization bool
	user                *uuid.UUID
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*Membership, error)
	predicates          []predicate.Membership
}

var _ ent.Mutation = (*MembershipMutation)(nil)

// membershipOption allows management of the mutation configuration using functional options.
type membershipOption func(*MembershipMutation)

// newMembershipMutation creates new mutation for the Membership entity.
func newMembershipMutation(c config, op Op, opts ...membershipOption) *MembershipMutation {
	m := &MembershipMutation{
		config:        c,
		op:            op,
		typ:           TypeMembership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMembershipID sets the ID field of the mutation.
func withMembershipID(id uuid.UUID) membershipOption {
	return func(m *MembershipMutation) {
		var (
			err   error
			once  sync.Once
			value *Membership
		)
		m.oldValue = func(ctx context.Context) (*Membership, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Membership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMembership sets the old Membership of the mutation.
func withMembership(node *Membership) membershipOption {
	return func(m *MembershipMutation) {
		m.oldValue = func(context.Context) (*Membership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MembershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MembershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Membership entities.
func (m *MembershipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MembershipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MembershipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Membership.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCurrent sets the "current" field.
func (m *MembershipMutation) SetCurrent(b bool) {
	m.current = &b
}

// Current returns the value of the "current" field in the mutation.
func (m *MembershipMutation) Current() (r bool, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// ResetCurrent resets all changes to the "current" field.
func (m *MembershipMutation) ResetCurrent() {
	m.current = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MembershipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MembershipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MembershipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MembershipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MembershipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MembershipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRole sets the "role" field.
func (m *MembershipMutation) SetRole(a authz.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *MembershipMutation) Role() (r authz.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldRole(ctx context.Context) (v authz.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MembershipMutation) ResetRole() {
	m.role = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *MembershipMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *MembershipMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *MembershipMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *MembershipMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *MembershipMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *MembershipMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MembershipMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MembershipMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MembershipMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MembershipMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MembershipMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MembershipMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MembershipMutation builder.
func (m *MembershipMutation) Where(ps ...predicate.Membership) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MembershipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MembershipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Membership, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MembershipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MembershipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Membership).
func (m *MembershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MembershipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.current != nil {
		fields = append(fields, membership.FieldCurrent)
	}
	if m.created_at != nil {
		fields = append(fields, membership.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membership.FieldUpdatedAt)
	}
	if m.role != nil {
		fields = append(fields, membership.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MembershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membership.FieldCurrent:
		return m.Current()
	case membership.FieldCreatedAt:
		return m.CreatedAt()
	case membership.FieldUpdatedAt:
		return m.UpdatedAt()
	case membership.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MembershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membership.FieldCurrent:
		return m.OldCurrent(ctx)
	case membership.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membership.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membership.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown Membership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membership.FieldCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	case membership.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membership.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membership.FieldRole:
		v, ok := value.(authz.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown Membership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MembershipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MembershipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Membership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MembershipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MembershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MembershipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Membership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MembershipMutation) ResetField(name string) error {
	switch name {
	case membership.FieldCurrent:
		m.ResetCurrent()
		return nil
	case membership.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membership.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membership.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Membership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MembershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, membership.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, membership.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MembershipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membership.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case membership.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MembershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MembershipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MembershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, membership.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, membership.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MembershipMutation) EdgeCleared(name string) bool {
	switch name {
	case membership.EdgeOrganization:
		return m.clearedorganization
	case membership.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MembershipMutation) ClearEdge(name string) error {
	switch name {
	case membership.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case membership.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Membership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MembershipMutation) ResetEdge(name string) error {
	switch name {
	case membership.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case membership.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Membership edge %s", name)
}

// OrgInvitationMutation represents an operation that mutates the OrgInvitation nodes in the graph.
type OrgInvitationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	receiver_email      *string
	status              *biz.OrgInvitationStatus
	created_at          *time.Time
	deleted_at          *time.Time
	role                *authz.Role
	clearedFields       map[string]struct{}
	organization        *uuid.UUID
	clearedorganization bool
	sender              *uuid.UUID
	clearedsender       bool
	done                bool
	oldValue            func(context.Context) (*OrgInvitation, error)
	predicates          []predicate.OrgInvitation
}

var _ ent.Mutation = (*OrgInvitationMutation)(nil)

// orginvitationOption allows management of the mutation configuration using functional options.
type orginvitationOption func(*OrgInvitationMutation)

// newOrgInvitationMutation creates new mutation for the OrgInvitation entity.
func newOrgInvitationMutation(c config, op Op, opts ...orginvitationOption) *OrgInvitationMutation {
	m := &OrgInvitationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgInvitation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgInvitationID sets the ID field of the mutation.
func withOrgInvitationID(id uuid.UUID) orginvitationOption {
	return func(m *OrgInvitationMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgInvitation
		)
		m.oldValue = func(ctx context.Context) (*OrgInvitation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgInvitation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgInvitation sets the old OrgInvitation of the mutation.
func withOrgInvitation(node *OrgInvitation) orginvitationOption {
	return func(m *OrgInvitationMutation) {
		m.oldValue = func(context.Context) (*OrgInvitation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgInvitationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgInvitationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgInvitation entities.
func (m *OrgInvitationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgInvitationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgInvitationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgInvitation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReceiverEmail sets the "receiver_email" field.
func (m *OrgInvitationMutation) SetReceiverEmail(s string) {
	m.receiver_email = &s
}

// ReceiverEmail returns the value of the "receiver_email" field in the mutation.
func (m *OrgInvitationMutation) ReceiverEmail() (r string, exists bool) {
	v := m.receiver_email
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverEmail returns the old "receiver_email" field's value of the OrgInvitation entity.
// If the OrgInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgInvitationMutation) OldReceiverEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverEmail: %w", err)
	}
	return oldValue.ReceiverEmail, nil
}

// ResetReceiverEmail resets all changes to the "receiver_email" field.
func (m *OrgInvitationMutation) ResetReceiverEmail() {
	m.receiver_email = nil
}

// SetStatus sets the "status" field.
func (m *OrgInvitationMutation) SetStatus(bis biz.OrgInvitationStatus) {
	m.status = &bis
}

// Status returns the value of the "status" field in the mutation.
func (m *OrgInvitationMutation) Status() (r biz.OrgInvitationStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrgInvitation entity.
// If the OrgInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgInvitationMutation) OldStatus(ctx context.Context) (v biz.OrgInvitationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrgInvitationMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgInvitationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgInvitationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgInvitation entity.
// If the OrgInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgInvitationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgInvitationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrgInvitationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrgInvitationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrgInvitation entity.
// If the OrgInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgInvitationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrgInvitationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orginvitation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrgInvitationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orginvitation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrgInvitationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orginvitation.FieldDeletedAt)
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrgInvitationMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrgInvitationMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrgInvitation entity.
// If the OrgInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgInvitationMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrgInvitationMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetSenderID sets the "sender_id" field.
func (m *OrgInvitationMutation) SetSenderID(u uuid.UUID) {
	m.sender = &u
}

// SenderID returns the value of the "sender_id" field in the mutation.
func (m *OrgInvitationMutation) SenderID() (r uuid.UUID, exists bool) {
	v := m.sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderID returns the old "sender_id" field's value of the OrgInvitation entity.
// If the OrgInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgInvitationMutation) OldSenderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderID: %w", err)
	}
	return oldValue.SenderID, nil
}

// ResetSenderID resets all changes to the "sender_id" field.
func (m *OrgInvitationMutation) ResetSenderID() {
	m.sender = nil
}

// SetRole sets the "role" field.
func (m *OrgInvitationMutation) SetRole(a authz.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *OrgInvitationMutation) Role() (r authz.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the OrgInvitation entity.
// If the OrgInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgInvitationMutation) OldRole(ctx context.Context) (v authz.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *OrgInvitationMutation) ClearRole() {
	m.role = nil
	m.clearedFields[orginvitation.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *OrgInvitationMutation) RoleCleared() bool {
	_, ok := m.clearedFields[orginvitation.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *OrgInvitationMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, orginvitation.FieldRole)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrgInvitationMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrgInvitationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrgInvitationMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrgInvitationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearSender clears the "sender" edge to the User entity.
func (m *OrgInvitationMutation) ClearSender() {
	m.clearedsender = true
}

// SenderCleared reports if the "sender" edge to the User entity was cleared.
func (m *OrgInvitationMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *OrgInvitationMutation) SenderIDs() (ids []uuid.UUID) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *OrgInvitationMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// Where appends a list predicates to the OrgInvitationMutation builder.
func (m *OrgInvitationMutation) Where(ps ...predicate.OrgInvitation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgInvitationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgInvitationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgInvitation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgInvitationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgInvitationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgInvitation).
func (m *OrgInvitationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgInvitationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.receiver_email != nil {
		fields = append(fields, orginvitation.FieldReceiverEmail)
	}
	if m.status != nil {
		fields = append(fields, orginvitation.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, orginvitation.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orginvitation.FieldDeletedAt)
	}
	if m.organization != nil {
		fields = append(fields, orginvitation.FieldOrganizationID)
	}
	if m.sender != nil {
		fields = append(fields, orginvitation.FieldSenderID)
	}
	if m.role != nil {
		fields = append(fields, orginvitation.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgInvitationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orginvitation.FieldReceiverEmail:
		return m.ReceiverEmail()
	case orginvitation.FieldStatus:
		return m.Status()
	case orginvitation.FieldCreatedAt:
		return m.CreatedAt()
	case orginvitation.FieldDeletedAt:
		return m.DeletedAt()
	case orginvitation.FieldOrganizationID:
		return m.OrganizationID()
	case orginvitation.FieldSenderID:
		return m.SenderID()
	case orginvitation.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgInvitationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orginvitation.FieldReceiverEmail:
		return m.OldReceiverEmail(ctx)
	case orginvitation.FieldStatus:
		return m.OldStatus(ctx)
	case orginvitation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orginvitation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orginvitation.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case orginvitation.FieldSenderID:
		return m.OldSenderID(ctx)
	case orginvitation.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown OrgInvitation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgInvitationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orginvitation.FieldReceiverEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverEmail(v)
		return nil
	case orginvitation.FieldStatus:
		v, ok := value.(biz.OrgInvitationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case orginvitation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orginvitation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orginvitation.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case orginvitation.FieldSenderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderID(v)
		return nil
	case orginvitation.FieldRole:
		v, ok := value.(authz.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown OrgInvitation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgInvitationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgInvitationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgInvitationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgInvitation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgInvitationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orginvitation.FieldDeletedAt) {
		fields = append(fields, orginvitation.FieldDeletedAt)
	}
	if m.FieldCleared(orginvitation.FieldRole) {
		fields = append(fields, orginvitation.FieldRole)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgInvitationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgInvitationMutation) ClearField(name string) error {
	switch name {
	case orginvitation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orginvitation.FieldRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown OrgInvitation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgInvitationMutation) ResetField(name string) error {
	switch name {
	case orginvitation.FieldReceiverEmail:
		m.ResetReceiverEmail()
		return nil
	case orginvitation.FieldStatus:
		m.ResetStatus()
		return nil
	case orginvitation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orginvitation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orginvitation.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case orginvitation.FieldSenderID:
		m.ResetSenderID()
		return nil
	case orginvitation.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown OrgInvitation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgInvitationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, orginvitation.EdgeOrganization)
	}
	if m.sender != nil {
		edges = append(edges, orginvitation.EdgeSender)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgInvitationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orginvitation.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case orginvitation.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgInvitationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgInvitationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgInvitationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, orginvitation.EdgeOrganization)
	}
	if m.clearedsender {
		edges = append(edges, orginvitation.EdgeSender)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgInvitationMutation) EdgeCleared(name string) bool {
	switch name {
	case orginvitation.EdgeOrganization:
		return m.clearedorganization
	case orginvitation.EdgeSender:
		return m.clearedsender
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgInvitationMutation) ClearEdge(name string) error {
	switch name {
	case orginvitation.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case orginvitation.EdgeSender:
		m.ClearSender()
		return nil
	}
	return fmt.Errorf("unknown OrgInvitation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgInvitationMutation) ResetEdge(name string) error {
	switch name {
	case orginvitation.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case orginvitation.EdgeSender:
		m.ResetSender()
		return nil
	}
	return fmt.Errorf("unknown OrgInvitation edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	name                      *string
	created_at                *time.Time
	clearedFields             map[string]struct{}
	memberships               map[uuid.UUID]struct{}
	removedmemberships        map[uuid.UUID]struct{}
	clearedmemberships        bool
	workflow_contracts        map[uuid.UUID]struct{}
	removedworkflow_contracts map[uuid.UUID]struct{}
	clearedworkflow_contracts bool
	workflows                 map[uuid.UUID]struct{}
	removedworkflows          map[uuid.UUID]struct{}
	clearedworkflows          bool
	cas_backends              map[uuid.UUID]struct{}
	removedcas_backends       map[uuid.UUID]struct{}
	clearedcas_backends       bool
	integrations              map[uuid.UUID]struct{}
	removedintegrations       map[uuid.UUID]struct{}
	clearedintegrations       bool
	api_tokens                map[uuid.UUID]struct{}
	removedapi_tokens         map[uuid.UUID]struct{}
	clearedapi_tokens         bool
	done                      bool
	oldValue                  func(context.Context) (*Organization, error)
	predicates                []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uuid.UUID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddMembershipIDs adds the "memberships" edge to the Membership entity by ids.
func (m *OrganizationMutation) AddMembershipIDs(ids ...uuid.UUID) {
	if m.memberships == nil {
		m.memberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the Membership entity.
func (m *OrganizationMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the Membership entity was cleared.
func (m *OrganizationMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the Membership entity by IDs.
func (m *OrganizationMutation) RemoveMembershipIDs(ids ...uuid.UUID) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the Membership entity.
func (m *OrganizationMutation) RemovedMembershipsIDs() (ids []uuid.UUID) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *OrganizationMutation) MembershipsIDs() (ids []uuid.UUID) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *OrganizationMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// AddWorkflowContractIDs adds the "workflow_contracts" edge to the WorkflowContract entity by ids.
func (m *OrganizationMutation) AddWorkflowContractIDs(ids ...uuid.UUID) {
	if m.workflow_contracts == nil {
		m.workflow_contracts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflow_contracts[ids[i]] = struct{}{}
	}
}

// ClearWorkflowContracts clears the "workflow_contracts" edge to the WorkflowContract entity.
func (m *OrganizationMutation) ClearWorkflowContracts() {
	m.clearedworkflow_contracts = true
}

// WorkflowContractsCleared reports if the "workflow_contracts" edge to the WorkflowContract entity was cleared.
func (m *OrganizationMutation) WorkflowContractsCleared() bool {
	return m.clearedworkflow_contracts
}

// RemoveWorkflowContractIDs removes the "workflow_contracts" edge to the WorkflowContract entity by IDs.
func (m *OrganizationMutation) RemoveWorkflowContractIDs(ids ...uuid.UUID) {
	if m.removedworkflow_contracts == nil {
		m.removedworkflow_contracts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflow_contracts, ids[i])
		m.removedworkflow_contracts[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowContracts returns the removed IDs of the "workflow_contracts" edge to the WorkflowContract entity.
func (m *OrganizationMutation) RemovedWorkflowContractsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflow_contracts {
		ids = append(ids, id)
	}
	return
}

// WorkflowContractsIDs returns the "workflow_contracts" edge IDs in the mutation.
func (m *OrganizationMutation) WorkflowContractsIDs() (ids []uuid.UUID) {
	for id := range m.workflow_contracts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowContracts resets all changes to the "workflow_contracts" edge.
func (m *OrganizationMutation) ResetWorkflowContracts() {
	m.workflow_contracts = nil
	m.clearedworkflow_contracts = false
	m.removedworkflow_contracts = nil
}

// AddWorkflowIDs adds the "workflows" edge to the Workflow entity by ids.
func (m *OrganizationMutation) AddWorkflowIDs(ids ...uuid.UUID) {
	if m.workflows == nil {
		m.workflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflow entity.
func (m *OrganizationMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflow entity was cleared.
func (m *OrganizationMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflow entity by IDs.
func (m *OrganizationMutation) RemoveWorkflowIDs(ids ...uuid.UUID) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflow entity.
func (m *OrganizationMutation) RemovedWorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *OrganizationMutation) WorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *OrganizationMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// AddCasBackendIDs adds the "cas_backends" edge to the CASBackend entity by ids.
func (m *OrganizationMutation) AddCasBackendIDs(ids ...uuid.UUID) {
	if m.cas_backends == nil {
		m.cas_backends = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cas_backends[ids[i]] = struct{}{}
	}
}

// ClearCasBackends clears the "cas_backends" edge to the CASBackend entity.
func (m *OrganizationMutation) ClearCasBackends() {
	m.clearedcas_backends = true
}

// CasBackendsCleared reports if the "cas_backends" edge to the CASBackend entity was cleared.
func (m *OrganizationMutation) CasBackendsCleared() bool {
	return m.clearedcas_backends
}

// RemoveCasBackendIDs removes the "cas_backends" edge to the CASBackend entity by IDs.
func (m *OrganizationMutation) RemoveCasBackendIDs(ids ...uuid.UUID) {
	if m.removedcas_backends == nil {
		m.removedcas_backends = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cas_backends, ids[i])
		m.removedcas_backends[ids[i]] = struct{}{}
	}
}

// RemovedCasBackends returns the removed IDs of the "cas_backends" edge to the CASBackend entity.
func (m *OrganizationMutation) RemovedCasBackendsIDs() (ids []uuid.UUID) {
	for id := range m.removedcas_backends {
		ids = append(ids, id)
	}
	return
}

// CasBackendsIDs returns the "cas_backends" edge IDs in the mutation.
func (m *OrganizationMutation) CasBackendsIDs() (ids []uuid.UUID) {
	for id := range m.cas_backends {
		ids = append(ids, id)
	}
	return
}

// ResetCasBackends resets all changes to the "cas_backends" edge.
func (m *OrganizationMutation) ResetCasBackends() {
	m.cas_backends = nil
	m.clearedcas_backends = false
	m.removedcas_backends = nil
}

// AddIntegrationIDs adds the "integrations" edge to the Integration entity by ids.
func (m *OrganizationMutation) AddIntegrationIDs(ids ...uuid.UUID) {
	if m.integrations == nil {
		m.integrations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.integrations[ids[i]] = struct{}{}
	}
}

// ClearIntegrations clears the "integrations" edge to the Integration entity.
func (m *OrganizationMutation) ClearIntegrations() {
	m.clearedintegrations = true
}

// IntegrationsCleared reports if the "integrations" edge to the Integration entity was cleared.
func (m *OrganizationMutation) IntegrationsCleared() bool {
	return m.clearedintegrations
}

// RemoveIntegrationIDs removes the "integrations" edge to the Integration entity by IDs.
func (m *OrganizationMutation) RemoveIntegrationIDs(ids ...uuid.UUID) {
	if m.removedintegrations == nil {
		m.removedintegrations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.integrations, ids[i])
		m.removedintegrations[ids[i]] = struct{}{}
	}
}

// RemovedIntegrations returns the removed IDs of the "integrations" edge to the Integration entity.
func (m *OrganizationMutation) RemovedIntegrationsIDs() (ids []uuid.UUID) {
	for id := range m.removedintegrations {
		ids = append(ids, id)
	}
	return
}

// IntegrationsIDs returns the "integrations" edge IDs in the mutation.
func (m *OrganizationMutation) IntegrationsIDs() (ids []uuid.UUID) {
	for id := range m.integrations {
		ids = append(ids, id)
	}
	return
}

// ResetIntegrations resets all changes to the "integrations" edge.
func (m *OrganizationMutation) ResetIntegrations() {
	m.integrations = nil
	m.clearedintegrations = false
	m.removedintegrations = nil
}

// AddAPITokenIDs adds the "api_tokens" edge to the APIToken entity by ids.
func (m *OrganizationMutation) AddAPITokenIDs(ids ...uuid.UUID) {
	if m.api_tokens == nil {
		m.api_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.api_tokens[ids[i]] = struct{}{}
	}
}

// ClearAPITokens clears the "api_tokens" edge to the APIToken entity.
func (m *OrganizationMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the APIToken entity was cleared.
func (m *OrganizationMutation) APITokensCleared() bool {
	return m.clearedapi_tokens
}

// RemoveAPITokenIDs removes the "api_tokens" edge to the APIToken entity by IDs.
func (m *OrganizationMutation) RemoveAPITokenIDs(ids ...uuid.UUID) {
	if m.removedapi_tokens == nil {
		m.removedapi_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.api_tokens, ids[i])
		m.removedapi_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAPITokens returns the removed IDs of the "api_tokens" edge to the APIToken entity.
func (m *OrganizationMutation) RemovedAPITokensIDs() (ids []uuid.UUID) {
	for id := range m.removedapi_tokens {
		ids = append(ids, id)
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
func (m *OrganizationMutation) APITokensIDs() (ids []uuid.UUID) {
	for id := range m.api_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *OrganizationMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
	m.removedapi_tokens = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.memberships != nil {
		edges = append(edges, organization.EdgeMemberships)
	}
	if m.workflow_contracts != nil {
		edges = append(edges, organization.EdgeWorkflowContracts)
	}
	if m.workflows != nil {
		edges = append(edges, organization.EdgeWorkflows)
	}
	if m.cas_backends != nil {
		edges = append(edges, organization.EdgeCasBackends)
	}
	if m.integrations != nil {
		edges = append(edges, organization.EdgeIntegrations)
	}
	if m.api_tokens != nil {
		edges = append(edges, organization.EdgeAPITokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWorkflowContracts:
		ids := make([]ent.Value, 0, len(m.workflow_contracts))
		for id := range m.workflow_contracts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeCasBackends:
		ids := make([]ent.Value, 0, len(m.cas_backends))
		for id := range m.cas_backends {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.integrations))
		for id := range m.integrations {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.api_tokens))
		for id := range m.api_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmemberships != nil {
		edges = append(edges, organization.EdgeMemberships)
	}
	if m.removedworkflow_contracts != nil {
		edges = append(edges, organization.EdgeWorkflowContracts)
	}
	if m.removedworkflows != nil {
		edges = append(edges, organization.EdgeWorkflows)
	}
	if m.removedcas_backends != nil {
		edges = append(edges, organization.EdgeCasBackends)
	}
	if m.removedintegrations != nil {
		edges = append(edges, organization.EdgeIntegrations)
	}
	if m.removedapi_tokens != nil {
		edges = append(edges, organization.EdgeAPITokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWorkflowContracts:
		ids := make([]ent.Value, 0, len(m.removedworkflow_contracts))
		for id := range m.removedworkflow_contracts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeCasBackends:
		ids := make([]ent.Value, 0, len(m.removedcas_backends))
		for id := range m.removedcas_backends {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.removedintegrations))
		for id := range m.removedintegrations {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.removedapi_tokens))
		for id := range m.removedapi_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmemberships {
		edges = append(edges, organization.EdgeMemberships)
	}
	if m.clearedworkflow_contracts {
		edges = append(edges, organization.EdgeWorkflowContracts)
	}
	if m.clearedworkflows {
		edges = append(edges, organization.EdgeWorkflows)
	}
	if m.clearedcas_backends {
		edges = append(edges, organization.EdgeCasBackends)
	}
	if m.clearedintegrations {
		edges = append(edges, organization.EdgeIntegrations)
	}
	if m.clearedapi_tokens {
		edges = append(edges, organization.EdgeAPITokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeMemberships:
		return m.clearedmemberships
	case organization.EdgeWorkflowContracts:
		return m.clearedworkflow_contracts
	case organization.EdgeWorkflows:
		return m.clearedworkflows
	case organization.EdgeCasBackends:
		return m.clearedcas_backends
	case organization.EdgeIntegrations:
		return m.clearedintegrations
	case organization.EdgeAPITokens:
		return m.clearedapi_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeMemberships:
		m.ResetMemberships()
		return nil
	case organization.EdgeWorkflowContracts:
		m.ResetWorkflowContracts()
		return nil
	case organization.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	case organization.EdgeCasBackends:
		m.ResetCasBackends()
		return nil
	case organization.EdgeIntegrations:
		m.ResetIntegrations()
		return nil
	case organization.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// ReferrerMutation represents an operation that mutates the Referrer nodes in the graph.
type ReferrerMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	digest             *string
	kind               *string
	downloadable       *bool
	created_at         *time.Time
	metadata           *map[string]string
	annotations        *map[string]string
	clearedFields      map[string]struct{}
	referred_by        map[uuid.UUID]struct{}
	removedreferred_by map[uuid.UUID]struct{}
	clearedreferred_by bool
	references         map[uuid.UUID]struct{}
	removedreferences  map[uuid.UUID]struct{}
	clearedreferences  bool
	workflows          map[uuid.UUID]struct{}
	removedworkflows   map[uuid.UUID]struct{}
	clearedworkflows   bool
	done               bool
	oldValue           func(context.Context) (*Referrer, error)
	predicates         []predicate.Referrer
}

var _ ent.Mutation = (*ReferrerMutation)(nil)

// referrerOption allows management of the mutation configuration using functional options.
type referrerOption func(*ReferrerMutation)

// newReferrerMutation creates new mutation for the Referrer entity.
func newReferrerMutation(c config, op Op, opts ...referrerOption) *ReferrerMutation {
	m := &ReferrerMutation{
		config:        c,
		op:            op,
		typ:           TypeReferrer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReferrerID sets the ID field of the mutation.
func withReferrerID(id uuid.UUID) referrerOption {
	return func(m *ReferrerMutation) {
		var (
			err   error
			once  sync.Once
			value *Referrer
		)
		m.oldValue = func(ctx context.Context) (*Referrer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Referrer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReferrer sets the old Referrer of the mutation.
func withReferrer(node *Referrer) referrerOption {
	return func(m *ReferrerMutation) {
		m.oldValue = func(context.Context) (*Referrer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReferrerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReferrerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Referrer entities.
func (m *ReferrerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReferrerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReferrerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Referrer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDigest sets the "digest" field.
func (m *ReferrerMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *ReferrerMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the Referrer entity.
// If the Referrer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferrerMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ResetDigest resets all changes to the "digest" field.
func (m *ReferrerMutation) ResetDigest() {
	m.digest = nil
}

// SetKind sets the "kind" field.
func (m *ReferrerMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *ReferrerMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Referrer entity.
// If the Referrer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferrerMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *ReferrerMutation) ResetKind() {
	m.kind = nil
}

// SetDownloadable sets the "downloadable" field.
func (m *ReferrerMutation) SetDownloadable(b bool) {
	m.downloadable = &b
}

// Downloadable returns the value of the "downloadable" field in the mutation.
func (m *ReferrerMutation) Downloadable() (r bool, exists bool) {
	v := m.downloadable
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadable returns the old "downloadable" field's value of the Referrer entity.
// If the Referrer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferrerMutation) OldDownloadable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadable: %w", err)
	}
	return oldValue.Downloadable, nil
}

// ResetDownloadable resets all changes to the "downloadable" field.
func (m *ReferrerMutation) ResetDownloadable() {
	m.downloadable = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReferrerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReferrerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Referrer entity.
// If the Referrer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferrerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReferrerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMetadata sets the "metadata" field.
func (m *ReferrerMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ReferrerMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Referrer entity.
// If the Referrer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferrerMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ReferrerMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[referrer.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ReferrerMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[referrer.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ReferrerMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, referrer.FieldMetadata)
}

// SetAnnotations sets the "annotations" field.
func (m *ReferrerMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ReferrerMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Referrer entity.
// If the Referrer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferrerMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ReferrerMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[referrer.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ReferrerMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[referrer.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ReferrerMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, referrer.FieldAnnotations)
}

// AddReferredByIDs adds the "referred_by" edge to the Referrer entity by ids.
func (m *ReferrerMutation) AddReferredByIDs(ids ...uuid.UUID) {
	if m.referred_by == nil {
		m.referred_by = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.referred_by[ids[i]] = struct{}{}
	}
}

// ClearReferredBy clears the "referred_by" edge to the Referrer entity.
func (m *ReferrerMutation) ClearReferredBy() {
	m.clearedreferred_by = true
}

// ReferredByCleared reports if the "referred_by" edge to the Referrer entity was cleared.
func (m *ReferrerMutation) ReferredByCleared() bool {
	return m.clearedreferred_by
}

// RemoveReferredByIDs removes the "referred_by" edge to the Referrer entity by IDs.
func (m *ReferrerMutation) RemoveReferredByIDs(ids ...uuid.UUID) {
	if m.removedreferred_by == nil {
		m.removedreferred_by = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.referred_by, ids[i])
		m.removedreferred_by[ids[i]] = struct{}{}
	}
}

// RemovedReferredBy returns the removed IDs of the "referred_by" edge to the Referrer entity.
func (m *ReferrerMutation) RemovedReferredByIDs() (ids []uuid.UUID) {
	for id := range m.removedreferred_by {
		ids = append(ids, id)
	}
	return
}

// ReferredByIDs returns the "referred_by" edge IDs in the mutation.
func (m *ReferrerMutation) ReferredByIDs() (ids []uuid.UUID) {
	for id := range m.referred_by {
		ids = append(ids, id)
	}
	return
}

// ResetReferredBy resets all changes to the "referred_by" edge.
func (m *ReferrerMutation) ResetReferredBy() {
	m.referred_by = nil
	m.clearedreferred_by = false
	m.removedreferred_by = nil
}

// AddReferenceIDs adds the "references" edge to the Referrer entity by ids.
func (m *ReferrerMutation) AddReferenceIDs(ids ...uuid.UUID) {
	if m.references == nil {
		m.references = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.references[ids[i]] = struct{}{}
	}
}

// ClearReferences clears the "references" edge to the Referrer entity.
func (m *ReferrerMutation) ClearReferences() {
	m.clearedreferences = true
}

// ReferencesCleared reports if the "references" edge to the Referrer entity was cleared.
func (m *ReferrerMutation) ReferencesCleared() bool {
	return m.clearedreferences
}

// RemoveReferenceIDs removes the "references" edge to the Referrer entity by IDs.
func (m *ReferrerMutation) RemoveReferenceIDs(ids ...uuid.UUID) {
	if m.removedreferences == nil {
		m.removedreferences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.references, ids[i])
		m.removedreferences[ids[i]] = struct{}{}
	}
}

// RemovedReferences returns the removed IDs of the "references" edge to the Referrer entity.
func (m *ReferrerMutation) RemovedReferencesIDs() (ids []uuid.UUID) {
	for id := range m.removedreferences {
		ids = append(ids, id)
	}
	return
}

// ReferencesIDs returns the "references" edge IDs in the mutation.
func (m *ReferrerMutation) ReferencesIDs() (ids []uuid.UUID) {
	for id := range m.references {
		ids = append(ids, id)
	}
	return
}

// ResetReferences resets all changes to the "references" edge.
func (m *ReferrerMutation) ResetReferences() {
	m.references = nil
	m.clearedreferences = false
	m.removedreferences = nil
}

// AddWorkflowIDs adds the "workflows" edge to the Workflow entity by ids.
func (m *ReferrerMutation) AddWorkflowIDs(ids ...uuid.UUID) {
	if m.workflows == nil {
		m.workflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflow entity.
func (m *ReferrerMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflow entity was cleared.
func (m *ReferrerMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflow entity by IDs.
func (m *ReferrerMutation) RemoveWorkflowIDs(ids ...uuid.UUID) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflow entity.
func (m *ReferrerMutation) RemovedWorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *ReferrerMutation) WorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *ReferrerMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// Where appends a list predicates to the ReferrerMutation builder.
func (m *ReferrerMutation) Where(ps ...predicate.Referrer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReferrerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReferrerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Referrer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReferrerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReferrerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Referrer).
func (m *ReferrerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReferrerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.digest != nil {
		fields = append(fields, referrer.FieldDigest)
	}
	if m.kind != nil {
		fields = append(fields, referrer.FieldKind)
	}
	if m.downloadable != nil {
		fields = append(fields, referrer.FieldDownloadable)
	}
	if m.created_at != nil {
		fields = append(fields, referrer.FieldCreatedAt)
	}
	if m.metadata != nil {
		fields = append(fields, referrer.FieldMetadata)
	}
	if m.annotations != nil {
		fields = append(fields, referrer.FieldAnnotations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReferrerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case referrer.FieldDigest:
		return m.Digest()
	case referrer.FieldKind:
		return m.Kind()
	case referrer.FieldDownloadable:
		return m.Downloadable()
	case referrer.FieldCreatedAt:
		return m.CreatedAt()
	case referrer.FieldMetadata:
		return m.Metadata()
	case referrer.FieldAnnotations:
		return m.Annotations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReferrerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case referrer.FieldDigest:
		return m.OldDigest(ctx)
	case referrer.FieldKind:
		return m.OldKind(ctx)
	case referrer.FieldDownloadable:
		return m.OldDownloadable(ctx)
	case referrer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case referrer.FieldMetadata:
		return m.OldMetadata(ctx)
	case referrer.FieldAnnotations:
		return m.OldAnnotations(ctx)
	}
	return nil, fmt.Errorf("unknown Referrer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferrerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case referrer.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	case referrer.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case referrer.FieldDownloadable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadable(v)
		return nil
	case referrer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case referrer.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case referrer.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	}
	return fmt.Errorf("unknown Referrer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReferrerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReferrerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferrerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Referrer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReferrerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(referrer.FieldMetadata) {
		fields = append(fields, referrer.FieldMetadata)
	}
	if m.FieldCleared(referrer.FieldAnnotations) {
		fields = append(fields, referrer.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReferrerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReferrerMutation) ClearField(name string) error {
	switch name {
	case referrer.FieldMetadata:
		m.ClearMetadata()
		return nil
	case referrer.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Referrer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReferrerMutation) ResetField(name string) error {
	switch name {
	case referrer.FieldDigest:
		m.ResetDigest()
		return nil
	case referrer.FieldKind:
		m.ResetKind()
		return nil
	case referrer.FieldDownloadable:
		m.ResetDownloadable()
		return nil
	case referrer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case referrer.FieldMetadata:
		m.ResetMetadata()
		return nil
	case referrer.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Referrer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReferrerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.referred_by != nil {
		edges = append(edges, referrer.EdgeReferredBy)
	}
	if m.references != nil {
		edges = append(edges, referrer.EdgeReferences)
	}
	if m.workflows != nil {
		edges = append(edges, referrer.EdgeWorkflows)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReferrerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case referrer.EdgeReferredBy:
		ids := make([]ent.Value, 0, len(m.referred_by))
		for id := range m.referred_by {
			ids = append(ids, id)
		}
		return ids
	case referrer.EdgeReferences:
		ids := make([]ent.Value, 0, len(m.references))
		for id := range m.references {
			ids = append(ids, id)
		}
		return ids
	case referrer.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReferrerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreferred_by != nil {
		edges = append(edges, referrer.EdgeReferredBy)
	}
	if m.removedreferences != nil {
		edges = append(edges, referrer.EdgeReferences)
	}
	if m.removedworkflows != nil {
		edges = append(edges, referrer.EdgeWorkflows)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReferrerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case referrer.EdgeReferredBy:
		ids := make([]ent.Value, 0, len(m.removedreferred_by))
		for id := range m.removedreferred_by {
			ids = append(ids, id)
		}
		return ids
	case referrer.EdgeReferences:
		ids := make([]ent.Value, 0, len(m.removedreferences))
		for id := range m.removedreferences {
			ids = append(ids, id)
		}
		return ids
	case referrer.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReferrerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreferred_by {
		edges = append(edges, referrer.EdgeReferredBy)
	}
	if m.clearedreferences {
		edges = append(edges, referrer.EdgeReferences)
	}
	if m.clearedworkflows {
		edges = append(edges, referrer.EdgeWorkflows)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReferrerMutation) EdgeCleared(name string) bool {
	switch name {
	case referrer.EdgeReferredBy:
		return m.clearedreferred_by
	case referrer.EdgeReferences:
		return m.clearedreferences
	case referrer.EdgeWorkflows:
		return m.clearedworkflows
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReferrerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Referrer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReferrerMutation) ResetEdge(name string) error {
	switch name {
	case referrer.EdgeReferredBy:
		m.ResetReferredBy()
		return nil
	case referrer.EdgeReferences:
		m.ResetReferences()
		return nil
	case referrer.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	}
	return fmt.Errorf("unknown Referrer edge %s", name)
}

// RobotAccountMutation represents an operation that mutates the RobotAccount nodes in the graph.
type RobotAccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	created_at          *time.Time
	revoked_at          *time.Time
	clearedFields       map[string]struct{}
	workflow            *uuid.UUID
	clearedworkflow     bool
	workflowruns        map[uuid.UUID]struct{}
	removedworkflowruns map[uuid.UUID]struct{}
	clearedworkflowruns bool
	done                bool
	oldValue            func(context.Context) (*RobotAccount, error)
	predicates          []predicate.RobotAccount
}

var _ ent.Mutation = (*RobotAccountMutation)(nil)

// robotaccountOption allows management of the mutation configuration using functional options.
type robotaccountOption func(*RobotAccountMutation)

// newRobotAccountMutation creates new mutation for the RobotAccount entity.
func newRobotAccountMutation(c config, op Op, opts ...robotaccountOption) *RobotAccountMutation {
	m := &RobotAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeRobotAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRobotAccountID sets the ID field of the mutation.
func withRobotAccountID(id uuid.UUID) robotaccountOption {
	return func(m *RobotAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *RobotAccount
		)
		m.oldValue = func(ctx context.Context) (*RobotAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RobotAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRobotAccount sets the old RobotAccount of the mutation.
func withRobotAccount(node *RobotAccount) robotaccountOption {
	return func(m *RobotAccountMutation) {
		m.oldValue = func(context.Context) (*RobotAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RobotAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RobotAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RobotAccount entities.
func (m *RobotAccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RobotAccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RobotAccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RobotAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RobotAccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RobotAccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RobotAccount entity.
// If the RobotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotAccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RobotAccountMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RobotAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RobotAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RobotAccount entity.
// If the RobotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RobotAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *RobotAccountMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *RobotAccountMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the RobotAccount entity.
// If the RobotAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotAccountMutation) OldRevokedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *RobotAccountMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[robotaccount.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *RobotAccountMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[robotaccount.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *RobotAccountMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, robotaccount.FieldRevokedAt)
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *RobotAccountMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *RobotAccountMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *RobotAccountMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *RobotAccountMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *RobotAccountMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *RobotAccountMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddWorkflowrunIDs adds the "workflowruns" edge to the WorkflowRun entity by ids.
func (m *RobotAccountMutation) AddWorkflowrunIDs(ids ...uuid.UUID) {
	if m.workflowruns == nil {
		m.workflowruns = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflowruns[ids[i]] = struct{}{}
	}
}

// ClearWorkflowruns clears the "workflowruns" edge to the WorkflowRun entity.
func (m *RobotAccountMutation) ClearWorkflowruns() {
	m.clearedworkflowruns = true
}

// WorkflowrunsCleared reports if the "workflowruns" edge to the WorkflowRun entity was cleared.
func (m *RobotAccountMutation) WorkflowrunsCleared() bool {
	return m.clearedworkflowruns
}

// RemoveWorkflowrunIDs removes the "workflowruns" edge to the WorkflowRun entity by IDs.
func (m *RobotAccountMutation) RemoveWorkflowrunIDs(ids ...uuid.UUID) {
	if m.removedworkflowruns == nil {
		m.removedworkflowruns = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflowruns, ids[i])
		m.removedworkflowruns[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowruns returns the removed IDs of the "workflowruns" edge to the WorkflowRun entity.
func (m *RobotAccountMutation) RemovedWorkflowrunsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflowruns {
		ids = append(ids, id)
	}
	return
}

// WorkflowrunsIDs returns the "workflowruns" edge IDs in the mutation.
func (m *RobotAccountMutation) WorkflowrunsIDs() (ids []uuid.UUID) {
	for id := range m.workflowruns {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowruns resets all changes to the "workflowruns" edge.
func (m *RobotAccountMutation) ResetWorkflowruns() {
	m.workflowruns = nil
	m.clearedworkflowruns = false
	m.removedworkflowruns = nil
}

// Where appends a list predicates to the RobotAccountMutation builder.
func (m *RobotAccountMutation) Where(ps ...predicate.RobotAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RobotAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RobotAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RobotAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RobotAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RobotAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RobotAccount).
func (m *RobotAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RobotAccountMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, robotaccount.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, robotaccount.FieldCreatedAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, robotaccount.FieldRevokedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RobotAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case robotaccount.FieldName:
		return m.Name()
	case robotaccount.FieldCreatedAt:
		return m.CreatedAt()
	case robotaccount.FieldRevokedAt:
		return m.RevokedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RobotAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case robotaccount.FieldName:
		return m.OldName(ctx)
	case robotaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case robotaccount.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RobotAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobotAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case robotaccount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case robotaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case robotaccount.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RobotAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RobotAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RobotAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobotAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RobotAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RobotAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(robotaccount.FieldRevokedAt) {
		fields = append(fields, robotaccount.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RobotAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RobotAccountMutation) ClearField(name string) error {
	switch name {
	case robotaccount.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown RobotAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RobotAccountMutation) ResetField(name string) error {
	switch name {
	case robotaccount.FieldName:
		m.ResetName()
		return nil
	case robotaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case robotaccount.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown RobotAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RobotAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflow != nil {
		edges = append(edges, robotaccount.EdgeWorkflow)
	}
	if m.workflowruns != nil {
		edges = append(edges, robotaccount.EdgeWorkflowruns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RobotAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case robotaccount.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case robotaccount.EdgeWorkflowruns:
		ids := make([]ent.Value, 0, len(m.workflowruns))
		for id := range m.workflowruns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RobotAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedworkflowruns != nil {
		edges = append(edges, robotaccount.EdgeWorkflowruns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RobotAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case robotaccount.EdgeWorkflowruns:
		ids := make([]ent.Value, 0, len(m.removedworkflowruns))
		for id := range m.removedworkflowruns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RobotAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflow {
		edges = append(edges, robotaccount.EdgeWorkflow)
	}
	if m.clearedworkflowruns {
		edges = append(edges, robotaccount.EdgeWorkflowruns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RobotAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case robotaccount.EdgeWorkflow:
		return m.clearedworkflow
	case robotaccount.EdgeWorkflowruns:
		return m.clearedworkflowruns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RobotAccountMutation) ClearEdge(name string) error {
	switch name {
	case robotaccount.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown RobotAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RobotAccountMutation) ResetEdge(name string) error {
	switch name {
	case robotaccount.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case robotaccount.EdgeWorkflowruns:
		m.ResetWorkflowruns()
		return nil
	}
	return fmt.Errorf("unknown RobotAccount edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	email              *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	memberships        map[uuid.UUID]struct{}
	removedmemberships map[uuid.UUID]struct{}
	clearedmemberships bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddMembershipIDs adds the "memberships" edge to the Membership entity by ids.
func (m *UserMutation) AddMembershipIDs(ids ...uuid.UUID) {
	if m.memberships == nil {
		m.memberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the Membership entity.
func (m *UserMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the Membership entity was cleared.
func (m *UserMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the Membership entity by IDs.
func (m *UserMutation) RemoveMembershipIDs(ids ...uuid.UUID) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the Membership entity.
func (m *UserMutation) RemovedMembershipsIDs() (ids []uuid.UUID) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *UserMutation) MembershipsIDs() (ids []uuid.UUID) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *UserMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.memberships != nil {
		edges = append(edges, user.EdgeMemberships)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmemberships != nil {
		edges = append(edges, user.EdgeMemberships)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmemberships {
		edges = append(edges, user.EdgeMemberships)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeMemberships:
		return m.clearedmemberships
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeMemberships:
		m.ResetMemberships()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	name                           *string
	project                        *string
	team                           *string
	runs_count                     *int
	addruns_count                  *int
	created_at                     *time.Time
	deleted_at                     *time.Time
	public                         *bool
	description                    *string
	clearedFields                  map[string]struct{}
	robotaccounts                  map[uuid.UUID]struct{}
	removedrobotaccounts           map[uuid.UUID]struct{}
	clearedrobotaccounts           bool
	workflowruns                   map[uuid.UUID]struct{}
	removedworkflowruns            map[uuid.UUID]struct{}
	clearedworkflowruns            bool
	organization                   *uuid.UUID
	clearedorganization            bool
	contract                       *uuid.UUID
	clearedcontract                bool
	integration_attachments        map[uuid.UUID]struct{}
	removedintegration_attachments map[uuid.UUID]struct{}
	clearedintegration_attachments bool
	referrers                      map[uuid.UUID]struct{}
	removedreferrers               map[uuid.UUID]struct{}
	clearedreferrers               bool
	done                           bool
	oldValue                       func(context.Context) (*Workflow, error)
	predicates                     []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id uuid.UUID) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workflow entities.
func (m *WorkflowMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowMutation) ResetName() {
	m.name = nil
}

// SetProject sets the "project" field.
func (m *WorkflowMutation) SetProject(s string) {
	m.project = &s
}

// Project returns the value of the "project" field in the mutation.
func (m *WorkflowMutation) Project() (r string, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProject returns the old "project" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldProject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProject: %w", err)
	}
	return oldValue.Project, nil
}

// ClearProject clears the value of the "project" field.
func (m *WorkflowMutation) ClearProject() {
	m.project = nil
	m.clearedFields[workflow.FieldProject] = struct{}{}
}

// ProjectCleared returns if the "project" field was cleared in this mutation.
func (m *WorkflowMutation) ProjectCleared() bool {
	_, ok := m.clearedFields[workflow.FieldProject]
	return ok
}

// ResetProject resets all changes to the "project" field.
func (m *WorkflowMutation) ResetProject() {
	m.project = nil
	delete(m.clearedFields, workflow.FieldProject)
}

// SetTeam sets the "team" field.
func (m *WorkflowMutation) SetTeam(s string) {
	m.team = &s
}

// Team returns the value of the "team" field in the mutation.
func (m *WorkflowMutation) Team() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeam returns the old "team" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTeam(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeam: %w", err)
	}
	return oldValue.Team, nil
}

// ClearTeam clears the value of the "team" field.
func (m *WorkflowMutation) ClearTeam() {
	m.team = nil
	m.clearedFields[workflow.FieldTeam] = struct{}{}
}

// TeamCleared returns if the "team" field was cleared in this mutation.
func (m *WorkflowMutation) TeamCleared() bool {
	_, ok := m.clearedFields[workflow.FieldTeam]
	return ok
}

// ResetTeam resets all changes to the "team" field.
func (m *WorkflowMutation) ResetTeam() {
	m.team = nil
	delete(m.clearedFields, workflow.FieldTeam)
}

// SetRunsCount sets the "runs_count" field.
func (m *WorkflowMutation) SetRunsCount(i int) {
	m.runs_count = &i
	m.addruns_count = nil
}

// RunsCount returns the value of the "runs_count" field in the mutation.
func (m *WorkflowMutation) RunsCount() (r int, exists bool) {
	v := m.runs_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRunsCount returns the old "runs_count" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldRunsCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunsCount: %w", err)
	}
	return oldValue.RunsCount, nil
}

// AddRunsCount adds i to the "runs_count" field.
func (m *WorkflowMutation) AddRunsCount(i int) {
	if m.addruns_count != nil {
		*m.addruns_count += i
	} else {
		m.addruns_count = &i
	}
}

// AddedRunsCount returns the value that was added to the "runs_count" field in this mutation.
func (m *WorkflowMutation) AddedRunsCount() (r int, exists bool) {
	v := m.addruns_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunsCount resets all changes to the "runs_count" field.
func (m *WorkflowMutation) ResetRunsCount() {
	m.runs_count = nil
	m.addruns_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WorkflowMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WorkflowMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WorkflowMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[workflow.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WorkflowMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workflow.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WorkflowMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, workflow.FieldDeletedAt)
}

// SetPublic sets the "public" field.
func (m *WorkflowMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *WorkflowMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *WorkflowMutation) ResetPublic() {
	m.public = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WorkflowMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WorkflowMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WorkflowMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflow.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflow.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflow.FieldDescription)
}

// AddRobotaccountIDs adds the "robotaccounts" edge to the RobotAccount entity by ids.
func (m *WorkflowMutation) AddRobotaccountIDs(ids ...uuid.UUID) {
	if m.robotaccounts == nil {
		m.robotaccounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.robotaccounts[ids[i]] = struct{}{}
	}
}

// ClearRobotaccounts clears the "robotaccounts" edge to the RobotAccount entity.
func (m *WorkflowMutation) ClearRobotaccounts() {
	m.clearedrobotaccounts = true
}

// RobotaccountsCleared reports if the "robotaccounts" edge to the RobotAccount entity was cleared.
func (m *WorkflowMutation) RobotaccountsCleared() bool {
	return m.clearedrobotaccounts
}

// RemoveRobotaccountIDs removes the "robotaccounts" edge to the RobotAccount entity by IDs.
func (m *WorkflowMutation) RemoveRobotaccountIDs(ids ...uuid.UUID) {
	if m.removedrobotaccounts == nil {
		m.removedrobotaccounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.robotaccounts, ids[i])
		m.removedrobotaccounts[ids[i]] = struct{}{}
	}
}

// RemovedRobotaccounts returns the removed IDs of the "robotaccounts" edge to the RobotAccount entity.
func (m *WorkflowMutation) RemovedRobotaccountsIDs() (ids []uuid.UUID) {
	for id := range m.removedrobotaccounts {
		ids = append(ids, id)
	}
	return
}

// RobotaccountsIDs returns the "robotaccounts" edge IDs in the mutation.
func (m *WorkflowMutation) RobotaccountsIDs() (ids []uuid.UUID) {
	for id := range m.robotaccounts {
		ids = append(ids, id)
	}
	return
}

// ResetRobotaccounts resets all changes to the "robotaccounts" edge.
func (m *WorkflowMutation) ResetRobotaccounts() {
	m.robotaccounts = nil
	m.clearedrobotaccounts = false
	m.removedrobotaccounts = nil
}

// AddWorkflowrunIDs adds the "workflowruns" edge to the WorkflowRun entity by ids.
func (m *WorkflowMutation) AddWorkflowrunIDs(ids ...uuid.UUID) {
	if m.workflowruns == nil {
		m.workflowruns = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflowruns[ids[i]] = struct{}{}
	}
}

// ClearWorkflowruns clears the "workflowruns" edge to the WorkflowRun entity.
func (m *WorkflowMutation) ClearWorkflowruns() {
	m.clearedworkflowruns = true
}

// WorkflowrunsCleared reports if the "workflowruns" edge to the WorkflowRun entity was cleared.
func (m *WorkflowMutation) WorkflowrunsCleared() bool {
	return m.clearedworkflowruns
}

// RemoveWorkflowrunIDs removes the "workflowruns" edge to the WorkflowRun entity by IDs.
func (m *WorkflowMutation) RemoveWorkflowrunIDs(ids ...uuid.UUID) {
	if m.removedworkflowruns == nil {
		m.removedworkflowruns = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflowruns, ids[i])
		m.removedworkflowruns[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowruns returns the removed IDs of the "workflowruns" edge to the WorkflowRun entity.
func (m *WorkflowMutation) RemovedWorkflowrunsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflowruns {
		ids = append(ids, id)
	}
	return
}

// WorkflowrunsIDs returns the "workflowruns" edge IDs in the mutation.
func (m *WorkflowMutation) WorkflowrunsIDs() (ids []uuid.UUID) {
	for id := range m.workflowruns {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowruns resets all changes to the "workflowruns" edge.
func (m *WorkflowMutation) ResetWorkflowruns() {
	m.workflowruns = nil
	m.clearedworkflowruns = false
	m.removedworkflowruns = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkflowMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkflowMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkflowMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetContractID sets the "contract" edge to the WorkflowContract entity by id.
func (m *WorkflowMutation) SetContractID(id uuid.UUID) {
	m.contract = &id
}

// ClearContract clears the "contract" edge to the WorkflowContract entity.
func (m *WorkflowMutation) ClearContract() {
	m.clearedcontract = true
}

// ContractCleared reports if the "contract" edge to the WorkflowContract entity was cleared.
func (m *WorkflowMutation) ContractCleared() bool {
	return m.clearedcontract
}

// ContractID returns the "contract" edge ID in the mutation.
func (m *WorkflowMutation) ContractID() (id uuid.UUID, exists bool) {
	if m.contract != nil {
		return *m.contract, true
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) ContractIDs() (ids []uuid.UUID) {
	if id := m.contract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *WorkflowMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
}

// AddIntegrationAttachmentIDs adds the "integration_attachments" edge to the IntegrationAttachment entity by ids.
func (m *WorkflowMutation) AddIntegrationAttachmentIDs(ids ...uuid.UUID) {
	if m.integration_attachments == nil {
		m.integration_attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.integration_attachments[ids[i]] = struct{}{}
	}
}

// ClearIntegrationAttachments clears the "integration_attachments" edge to the IntegrationAttachment entity.
func (m *WorkflowMutation) ClearIntegrationAttachments() {
	m.clearedintegration_attachments = true
}

// IntegrationAttachmentsCleared reports if the "integration_attachments" edge to the IntegrationAttachment entity was cleared.
func (m *WorkflowMutation) IntegrationAttachmentsCleared() bool {
	return m.clearedintegration_attachments
}

// RemoveIntegrationAttachmentIDs removes the "integration_attachments" edge to the IntegrationAttachment entity by IDs.
func (m *WorkflowMutation) RemoveIntegrationAttachmentIDs(ids ...uuid.UUID) {
	if m.removedintegration_attachments == nil {
		m.removedintegration_attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.integration_attachments, ids[i])
		m.removedintegration_attachments[ids[i]] = struct{}{}
	}
}

// RemovedIntegrationAttachments returns the removed IDs of the "integration_attachments" edge to the IntegrationAttachment entity.
func (m *WorkflowMutation) RemovedIntegrationAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedintegration_attachments {
		ids = append(ids, id)
	}
	return
}

// IntegrationAttachmentsIDs returns the "integration_attachments" edge IDs in the mutation.
func (m *WorkflowMutation) IntegrationAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.integration_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetIntegrationAttachments resets all changes to the "integration_attachments" edge.
func (m *WorkflowMutation) ResetIntegrationAttachments() {
	m.integration_attachments = nil
	m.clearedintegration_attachments = false
	m.removedintegration_attachments = nil
}

// AddReferrerIDs adds the "referrers" edge to the Referrer entity by ids.
func (m *WorkflowMutation) AddReferrerIDs(ids ...uuid.UUID) {
	if m.referrers == nil {
		m.referrers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.referrers[ids[i]] = struct{}{}
	}
}

// ClearReferrers clears the "referrers" edge to the Referrer entity.
func (m *WorkflowMutation) ClearReferrers() {
	m.clearedreferrers = true
}

// ReferrersCleared reports if the "referrers" edge to the Referrer entity was cleared.
func (m *WorkflowMutation) ReferrersCleared() bool {
	return m.clearedreferrers
}

// RemoveReferrerIDs removes the "referrers" edge to the Referrer entity by IDs.
func (m *WorkflowMutation) RemoveReferrerIDs(ids ...uuid.UUID) {
	if m.removedreferrers == nil {
		m.removedreferrers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.referrers, ids[i])
		m.removedreferrers[ids[i]] = struct{}{}
	}
}

// RemovedReferrers returns the removed IDs of the "referrers" edge to the Referrer entity.
func (m *WorkflowMutation) RemovedReferrersIDs() (ids []uuid.UUID) {
	for id := range m.removedreferrers {
		ids = append(ids, id)
	}
	return
}

// ReferrersIDs returns the "referrers" edge IDs in the mutation.
func (m *WorkflowMutation) ReferrersIDs() (ids []uuid.UUID) {
	for id := range m.referrers {
		ids = append(ids, id)
	}
	return
}

// ResetReferrers resets all changes to the "referrers" edge.
func (m *WorkflowMutation) ResetReferrers() {
	m.referrers = nil
	m.clearedreferrers = false
	m.removedreferrers = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, workflow.FieldName)
	}
	if m.project != nil {
		fields = append(fields, workflow.FieldProject)
	}
	if m.team != nil {
		fields = append(fields, workflow.FieldTeam)
	}
	if m.runs_count != nil {
		fields = append(fields, workflow.FieldRunsCount)
	}
	if m.created_at != nil {
		fields = append(fields, workflow.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, workflow.FieldDeletedAt)
	}
	if m.public != nil {
		fields = append(fields, workflow.FieldPublic)
	}
	if m.organization != nil {
		fields = append(fields, workflow.FieldOrganizationID)
	}
	if m.description != nil {
		fields = append(fields, workflow.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldName:
		return m.Name()
	case workflow.FieldProject:
		return m.Project()
	case workflow.FieldTeam:
		return m.Team()
	case workflow.FieldRunsCount:
		return m.RunsCount()
	case workflow.FieldCreatedAt:
		return m.CreatedAt()
	case workflow.FieldDeletedAt:
		return m.DeletedAt()
	case workflow.FieldPublic:
		return m.Public()
	case workflow.FieldOrganizationID:
		return m.OrganizationID()
	case workflow.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldName:
		return m.OldName(ctx)
	case workflow.FieldProject:
		return m.OldProject(ctx)
	case workflow.FieldTeam:
		return m.OldTeam(ctx)
	case workflow.FieldRunsCount:
		return m.OldRunsCount(ctx)
	case workflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflow.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workflow.FieldPublic:
		return m.OldPublic(ctx)
	case workflow.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case workflow.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflow.FieldProject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProject(v)
		return nil
	case workflow.FieldTeam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeam(v)
		return nil
	case workflow.FieldRunsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunsCount(v)
		return nil
	case workflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflow.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workflow.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case workflow.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case workflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	var fields []string
	if m.addruns_count != nil {
		fields = append(fields, workflow.FieldRunsCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldRunsCount:
		return m.AddedRunsCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldRunsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunsCount(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldProject) {
		fields = append(fields, workflow.FieldProject)
	}
	if m.FieldCleared(workflow.FieldTeam) {
		fields = append(fields, workflow.FieldTeam)
	}
	if m.FieldCleared(workflow.FieldDeletedAt) {
		fields = append(fields, workflow.FieldDeletedAt)
	}
	if m.FieldCleared(workflow.FieldDescription) {
		fields = append(fields, workflow.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldProject:
		m.ClearProject()
		return nil
	case workflow.FieldTeam:
		m.ClearTeam()
		return nil
	case workflow.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workflow.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldName:
		m.ResetName()
		return nil
	case workflow.FieldProject:
		m.ResetProject()
		return nil
	case workflow.FieldTeam:
		m.ResetTeam()
		return nil
	case workflow.FieldRunsCount:
		m.ResetRunsCount()
		return nil
	case workflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflow.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workflow.FieldPublic:
		m.ResetPublic()
		return nil
	case workflow.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case workflow.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.robotaccounts != nil {
		edges = append(edges, workflow.EdgeRobotaccounts)
	}
	if m.workflowruns != nil {
		edges = append(edges, workflow.EdgeWorkflowruns)
	}
	if m.organization != nil {
		edges = append(edges, workflow.EdgeOrganization)
	}
	if m.contract != nil {
		edges = append(edges, workflow.EdgeContract)
	}
	if m.integration_attachments != nil {
		edges = append(edges, workflow.EdgeIntegrationAttachments)
	}
	if m.referrers != nil {
		edges = append(edges, workflow.EdgeReferrers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeRobotaccounts:
		ids := make([]ent.Value, 0, len(m.robotaccounts))
		for id := range m.robotaccounts {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeWorkflowruns:
		ids := make([]ent.Value, 0, len(m.workflowruns))
		for id := range m.workflowruns {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeContract:
		if id := m.contract; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeIntegrationAttachments:
		ids := make([]ent.Value, 0, len(m.integration_attachments))
		for id := range m.integration_attachments {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeReferrers:
		ids := make([]ent.Value, 0, len(m.referrers))
		for id := range m.referrers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedrobotaccounts != nil {
		edges = append(edges, workflow.EdgeRobotaccounts)
	}
	if m.removedworkflowruns != nil {
		edges = append(edges, workflow.EdgeWorkflowruns)
	}
	if m.removedintegration_attachments != nil {
		edges = append(edges, workflow.EdgeIntegrationAttachments)
	}
	if m.removedreferrers != nil {
		edges = append(edges, workflow.EdgeReferrers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeRobotaccounts:
		ids := make([]ent.Value, 0, len(m.removedrobotaccounts))
		for id := range m.removedrobotaccounts {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeWorkflowruns:
		ids := make([]ent.Value, 0, len(m.removedworkflowruns))
		for id := range m.removedworkflowruns {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeIntegrationAttachments:
		ids := make([]ent.Value, 0, len(m.removedintegration_attachments))
		for id := range m.removedintegration_attachments {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeReferrers:
		ids := make([]ent.Value, 0, len(m.removedreferrers))
		for id := range m.removedreferrers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedrobotaccounts {
		edges = append(edges, workflow.EdgeRobotaccounts)
	}
	if m.clearedworkflowruns {
		edges = append(edges, workflow.EdgeWorkflowruns)
	}
	if m.clearedorganization {
		edges = append(edges, workflow.EdgeOrganization)
	}
	if m.clearedcontract {
		edges = append(edges, workflow.EdgeContract)
	}
	if m.clearedintegration_attachments {
		edges = append(edges, workflow.EdgeIntegrationAttachments)
	}
	if m.clearedreferrers {
		edges = append(edges, workflow.EdgeReferrers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeRobotaccounts:
		return m.clearedrobotaccounts
	case workflow.EdgeWorkflowruns:
		return m.clearedworkflowruns
	case workflow.EdgeOrganization:
		return m.clearedorganization
	case workflow.EdgeContract:
		return m.clearedcontract
	case workflow.EdgeIntegrationAttachments:
		return m.clearedintegration_attachments
	case workflow.EdgeReferrers:
		return m.clearedreferrers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	case workflow.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case workflow.EdgeContract:
		m.ClearContract()
		return nil
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeRobotaccounts:
		m.ResetRobotaccounts()
		return nil
	case workflow.EdgeWorkflowruns:
		m.ResetWorkflowruns()
		return nil
	case workflow.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case workflow.EdgeContract:
		m.ResetContract()
		return nil
	case workflow.EdgeIntegrationAttachments:
		m.ResetIntegrationAttachments()
		return nil
	case workflow.EdgeReferrers:
		m.ResetReferrers()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}

// WorkflowContractMutation represents an operation that mutates the WorkflowContract nodes in the graph.
type WorkflowContractMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	created_at          *time.Time
	deleted_at          *time.Time
	description         *string
	clearedFields       map[string]struct{}
	versions            map[uuid.UUID]struct{}
	removedversions     map[uuid.UUID]struct{}
	clearedversions     bool
	organization        *uuid.UUID
	clearedorganization bool
	workflows           map[uuid.UUID]struct{}
	removedworkflows    map[uuid.UUID]struct{}
	clearedworkflows    bool
	done                bool
	oldValue            func(context.Context) (*WorkflowContract, error)
	predicates          []predicate.WorkflowContract
}

var _ ent.Mutation = (*WorkflowContractMutation)(nil)

// workflowcontractOption allows management of the mutation configuration using functional options.
type workflowcontractOption func(*WorkflowContractMutation)

// newWorkflowContractMutation creates new mutation for the WorkflowContract entity.
func newWorkflowContractMutation(c config, op Op, opts ...workflowcontractOption) *WorkflowContractMutation {
	m := &WorkflowContractMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowContractID sets the ID field of the mutation.
func withWorkflowContractID(id uuid.UUID) workflowcontractOption {
	return func(m *WorkflowContractMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowContract
		)
		m.oldValue = func(ctx context.Context) (*WorkflowContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowContract sets the old WorkflowContract of the mutation.
func withWorkflowContract(node *WorkflowContract) workflowcontractOption {
	return func(m *WorkflowContractMutation) {
		m.oldValue = func(context.Context) (*WorkflowContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowContract entities.
func (m *WorkflowContractMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowContractMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowContractMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkflowContract entity.
// If the WorkflowContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowContractMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowContract entity.
// If the WorkflowContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WorkflowContractMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WorkflowContractMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WorkflowContract entity.
// If the WorkflowContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowContractMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WorkflowContractMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[workflowcontract.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WorkflowContractMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workflowcontract.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WorkflowContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, workflowcontract.FieldDeletedAt)
}

// SetDescription sets the "description" field.
func (m *WorkflowContractMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowContractMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkflowContract entity.
// If the WorkflowContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowContractMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowContractMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflowcontract.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowContractMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflowcontract.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowContractMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflowcontract.FieldDescription)
}

// AddVersionIDs adds the "versions" edge to the WorkflowContractVersion entity by ids.
func (m *WorkflowContractMutation) AddVersionIDs(ids ...uuid.UUID) {
	if m.versions == nil {
		m.versions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the WorkflowContractVersion entity.
func (m *WorkflowContractMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the WorkflowContractVersion entity was cleared.
func (m *WorkflowContractMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the WorkflowContractVersion entity by IDs.
func (m *WorkflowContractMutation) RemoveVersionIDs(ids ...uuid.UUID) {
	if m.removedversions == nil {
		m.removedversions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the WorkflowContractVersion entity.
func (m *WorkflowContractMutation) RemovedVersionsIDs() (ids []uuid.UUID) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *WorkflowContractMutation) VersionsIDs() (ids []uuid.UUID) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *WorkflowContractMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *WorkflowContractMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkflowContractMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkflowContractMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *WorkflowContractMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkflowContractMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkflowContractMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddWorkflowIDs adds the "workflows" edge to the Workflow entity by ids.
func (m *WorkflowContractMutation) AddWorkflowIDs(ids ...uuid.UUID) {
	if m.workflows == nil {
		m.workflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflow entity.
func (m *WorkflowContractMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflow entity was cleared.
func (m *WorkflowContractMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflow entity by IDs.
func (m *WorkflowContractMutation) RemoveWorkflowIDs(ids ...uuid.UUID) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflow entity.
func (m *WorkflowContractMutation) RemovedWorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *WorkflowContractMutation) WorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *WorkflowContractMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// Where appends a list predicates to the WorkflowContractMutation builder.
func (m *WorkflowContractMutation) Where(ps ...predicate.WorkflowContract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowContract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowContract).
func (m *WorkflowContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowContractMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, workflowcontract.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, workflowcontract.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, workflowcontract.FieldDeletedAt)
	}
	if m.description != nil {
		fields = append(fields, workflowcontract.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowcontract.FieldName:
		return m.Name()
	case workflowcontract.FieldCreatedAt:
		return m.CreatedAt()
	case workflowcontract.FieldDeletedAt:
		return m.DeletedAt()
	case workflowcontract.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowcontract.FieldName:
		return m.OldName(ctx)
	case workflowcontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowcontract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workflowcontract.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowcontract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflowcontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowcontract.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workflowcontract.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowContractMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowContractMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowcontract.FieldDeletedAt) {
		fields = append(fields, workflowcontract.FieldDeletedAt)
	}
	if m.FieldCleared(workflowcontract.FieldDescription) {
		fields = append(fields, workflowcontract.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowContractMutation) ClearField(name string) error {
	switch name {
	case workflowcontract.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workflowcontract.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkflowContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowContractMutation) ResetField(name string) error {
	switch name {
	case workflowcontract.FieldName:
		m.ResetName()
		return nil
	case workflowcontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowcontract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workflowcontract.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkflowContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.versions != nil {
		edges = append(edges, workflowcontract.EdgeVersions)
	}
	if m.organization != nil {
		edges = append(edges, workflowcontract.EdgeOrganization)
	}
	if m.workflows != nil {
		edges = append(edges, workflowcontract.EdgeWorkflows)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowcontract.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case workflowcontract.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case workflowcontract.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedversions != nil {
		edges = append(edges, workflowcontract.EdgeVersions)
	}
	if m.removedworkflows != nil {
		edges = append(edges, workflowcontract.EdgeWorkflows)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflowcontract.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case workflowcontract.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedversions {
		edges = append(edges, workflowcontract.EdgeVersions)
	}
	if m.clearedorganization {
		edges = append(edges, workflowcontract.EdgeOrganization)
	}
	if m.clearedworkflows {
		edges = append(edges, workflowcontract.EdgeWorkflows)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowContractMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowcontract.EdgeVersions:
		return m.clearedversions
	case workflowcontract.EdgeOrganization:
		return m.clearedorganization
	case workflowcontract.EdgeWorkflows:
		return m.clearedworkflows
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowContractMutation) ClearEdge(name string) error {
	switch name {
	case workflowcontract.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown WorkflowContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowContractMutation) ResetEdge(name string) error {
	switch name {
	case workflowcontract.EdgeVersions:
		m.ResetVersions()
		return nil
	case workflowcontract.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case workflowcontract.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	}
	return fmt.Errorf("unknown WorkflowContract edge %s", name)
}

// WorkflowContractVersionMutation represents an operation that mutates the WorkflowContractVersion nodes in the graph.
type WorkflowContractVersionMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	body            *[]byte
	revision        *int
	addrevision     *int
	created_at      *time.Time
	clearedFields   map[string]struct{}
	contract        *uuid.UUID
	clearedcontract bool
	done            bool
	oldValue        func(context.Context) (*WorkflowContractVersion, error)
	predicates      []predicate.WorkflowContractVersion
}

var _ ent.Mutation = (*WorkflowContractVersionMutation)(nil)

// workflowcontractversionOption allows management of the mutation configuration using functional options.
type workflowcontractversionOption func(*WorkflowContractVersionMutation)

// newWorkflowContractVersionMutation creates new mutation for the WorkflowContractVersion entity.
func newWorkflowContractVersionMutation(c config, op Op, opts ...workflowcontractversionOption) *WorkflowContractVersionMutation {
	m := &WorkflowContractVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowContractVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowContractVersionID sets the ID field of the mutation.
func withWorkflowContractVersionID(id uuid.UUID) workflowcontractversionOption {
	return func(m *WorkflowContractVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowContractVersion
		)
		m.oldValue = func(ctx context.Context) (*WorkflowContractVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowContractVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowContractVersion sets the old WorkflowContractVersion of the mutation.
func withWorkflowContractVersion(node *WorkflowContractVersion) workflowcontractversionOption {
	return func(m *WorkflowContractVersionMutation) {
		m.oldValue = func(context.Context) (*WorkflowContractVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowContractVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowContractVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowContractVersion entities.
func (m *WorkflowContractVersionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowContractVersionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowContractVersionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowContractVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBody sets the "body" field.
func (m *WorkflowContractVersionMutation) SetBody(b []byte) {
	m.body = &b
}

// Body returns the value of the "body" field in the mutation.
func (m *WorkflowContractVersionMutation) Body() (r []byte, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the WorkflowContractVersion entity.
// If the WorkflowContractVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowContractVersionMutation) OldBody(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *WorkflowContractVersionMutation) ResetBody() {
	m.body = nil
}

// SetRevision sets the "revision" field.
func (m *WorkflowContractVersionMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *WorkflowContractVersionMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the WorkflowContractVersion entity.
// If the WorkflowContractVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowContractVersionMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *WorkflowContractVersionMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *WorkflowContractVersionMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *WorkflowContractVersionMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowContractVersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowContractVersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowContractVersion entity.
// If the WorkflowContractVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowContractVersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowContractVersionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetContractID sets the "contract" edge to the WorkflowContract entity by id.
func (m *WorkflowContractVersionMutation) SetContractID(id uuid.UUID) {
	m.contract = &id
}

// ClearContract clears the "contract" edge to the WorkflowContract entity.
func (m *WorkflowContractVersionMutation) ClearContract() {
	m.clearedcontract = true
}

// ContractCleared reports if the "contract" edge to the WorkflowContract entity was cleared.
func (m *WorkflowContractVersionMutation) ContractCleared() bool {
	return m.clearedcontract
}

// ContractID returns the "contract" edge ID in the mutation.
func (m *WorkflowContractVersionMutation) ContractID() (id uuid.UUID, exists bool) {
	if m.contract != nil {
		return *m.contract, true
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractID instead. It exists only for internal usage by the builders.
func (m *WorkflowContractVersionMutation) ContractIDs() (ids []uuid.UUID) {
	if id := m.contract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *WorkflowContractVersionMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
}

// Where appends a list predicates to the WorkflowContractVersionMutation builder.
func (m *WorkflowContractVersionMutation) Where(ps ...predicate.WorkflowContractVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowContractVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowContractVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowContractVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowContractVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowContractVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowContractVersion).
func (m *WorkflowContractVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowContractVersionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.body != nil {
		fields = append(fields, workflowcontractversion.FieldBody)
	}
	if m.revision != nil {
		fields = append(fields, workflowcontractversion.FieldRevision)
	}
	if m.created_at != nil {
		fields = append(fields, workflowcontractversion.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowContractVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowcontractversion.FieldBody:
		return m.Body()
	case workflowcontractversion.FieldRevision:
		return m.Revision()
	case workflowcontractversion.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowContractVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowcontractversion.FieldBody:
		return m.OldBody(ctx)
	case workflowcontractversion.FieldRevision:
		return m.OldRevision(ctx)
	case workflowcontractversion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowContractVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowContractVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowcontractversion.FieldBody:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case workflowcontractversion.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case workflowcontractversion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowContractVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowContractVersionMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, workflowcontractversion.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowContractVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowcontractversion.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowContractVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowcontractversion.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowContractVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowContractVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowContractVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowContractVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkflowContractVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowContractVersionMutation) ResetField(name string) error {
	switch name {
	case workflowcontractversion.FieldBody:
		m.ResetBody()
		return nil
	case workflowcontractversion.FieldRevision:
		m.ResetRevision()
		return nil
	case workflowcontractversion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowContractVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowContractVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.contract != nil {
		edges = append(edges, workflowcontractversion.EdgeContract)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowContractVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowcontractversion.EdgeContract:
		if id := m.contract; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowContractVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowContractVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowContractVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontract {
		edges = append(edges, workflowcontractversion.EdgeContract)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowContractVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowcontractversion.EdgeContract:
		return m.clearedcontract
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowContractVersionMutation) ClearEdge(name string) error {
	switch name {
	case workflowcontractversion.EdgeContract:
		m.ClearContract()
		return nil
	}
	return fmt.Errorf("unknown WorkflowContractVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowContractVersionMutation) ResetEdge(name string) error {
	switch name {
	case workflowcontractversion.EdgeContract:
		m.ResetContract()
		return nil
	}
	return fmt.Errorf("unknown WorkflowContractVersion edge %s", name)
}

// WorkflowRunMutation represents an operation that mutates the WorkflowRun nodes in the graph.
type WorkflowRunMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	created_at                  *time.Time
	finished_at                 *time.Time
	state                       *biz.WorkflowRunStatus
	reason                      *string
	run_url                     *string
	runner_type                 *string
	attestation                 **dsse.Envelope
	attestation_digest          *string
	attestation_state           *[]byte
	contract_revision_used      *int
	addcontract_revision_used   *int
	contract_revision_latest    *int
	addcontract_revision_latest *int
	clearedFields               map[string]struct{}
	workflow                    *uuid.UUID
	clearedworkflow             bool
	robotaccount                *uuid.UUID
	clearedrobotaccount         bool
	contract_version            *uuid.UUID
	clearedcontract_version     bool
	cas_backends                map[uuid.UUID]struct{}
	removedcas_backends         map[uuid.UUID]struct{}
	clearedcas_backends         bool
	done                        bool
	oldValue                    func(context.Context) (*WorkflowRun, error)
	predicates                  []predicate.WorkflowRun
}

var _ ent.Mutation = (*WorkflowRunMutation)(nil)

// workflowrunOption allows management of the mutation configuration using functional options.
type workflowrunOption func(*WorkflowRunMutation)

// newWorkflowRunMutation creates new mutation for the WorkflowRun entity.
func newWorkflowRunMutation(c config, op Op, opts ...workflowrunOption) *WorkflowRunMutation {
	m := &WorkflowRunMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowRunID sets the ID field of the mutation.
func withWorkflowRunID(id uuid.UUID) workflowrunOption {
	return func(m *WorkflowRunMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowRun
		)
		m.oldValue = func(ctx context.Context) (*WorkflowRun, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowRun.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowRun sets the old WorkflowRun of the mutation.
func withWorkflowRun(node *WorkflowRun) workflowrunOption {
	return func(m *WorkflowRunMutation) {
		m.oldValue = func(context.Context) (*WorkflowRun, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowRunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowRunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowRun entities.
func (m *WorkflowRunMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowRunMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowRunMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowRun.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowRunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowRunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowRunMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *WorkflowRunMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *WorkflowRunMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *WorkflowRunMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[workflowrun.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *WorkflowRunMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[workflowrun.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *WorkflowRunMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, workflowrun.FieldFinishedAt)
}

// SetState sets the "state" field.
func (m *WorkflowRunMutation) SetState(brs biz.WorkflowRunStatus) {
	m.state = &brs
}

// State returns the value of the "state" field in the mutation.
func (m *WorkflowRunMutation) State() (r biz.WorkflowRunStatus, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldState(ctx context.Context) (v biz.WorkflowRunStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *WorkflowRunMutation) ResetState() {
	m.state = nil
}

// SetReason sets the "reason" field.
func (m *WorkflowRunMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *WorkflowRunMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *WorkflowRunMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[workflowrun.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *WorkflowRunMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[workflowrun.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *WorkflowRunMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, workflowrun.FieldReason)
}

// SetRunURL sets the "run_url" field.
func (m *WorkflowRunMutation) SetRunURL(s string) {
	m.run_url = &s
}

// RunURL returns the value of the "run_url" field in the mutation.
func (m *WorkflowRunMutation) RunURL() (r string, exists bool) {
	v := m.run_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRunURL returns the old "run_url" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldRunURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunURL: %w", err)
	}
	return oldValue.RunURL, nil
}

// ClearRunURL clears the value of the "run_url" field.
func (m *WorkflowRunMutation) ClearRunURL() {
	m.run_url = nil
	m.clearedFields[workflowrun.FieldRunURL] = struct{}{}
}

// RunURLCleared returns if the "run_url" field was cleared in this mutation.
func (m *WorkflowRunMutation) RunURLCleared() bool {
	_, ok := m.clearedFields[workflowrun.FieldRunURL]
	return ok
}

// ResetRunURL resets all changes to the "run_url" field.
func (m *WorkflowRunMutation) ResetRunURL() {
	m.run_url = nil
	delete(m.clearedFields, workflowrun.FieldRunURL)
}

// SetRunnerType sets the "runner_type" field.
func (m *WorkflowRunMutation) SetRunnerType(s string) {
	m.runner_type = &s
}

// RunnerType returns the value of the "runner_type" field in the mutation.
func (m *WorkflowRunMutation) RunnerType() (r string, exists bool) {
	v := m.runner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRunnerType returns the old "runner_type" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldRunnerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunnerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunnerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunnerType: %w", err)
	}
	return oldValue.RunnerType, nil
}

// ClearRunnerType clears the value of the "runner_type" field.
func (m *WorkflowRunMutation) ClearRunnerType() {
	m.runner_type = nil
	m.clearedFields[workflowrun.FieldRunnerType] = struct{}{}
}

// RunnerTypeCleared returns if the "runner_type" field was cleared in this mutation.
func (m *WorkflowRunMutation) RunnerTypeCleared() bool {
	_, ok := m.clearedFields[workflowrun.FieldRunnerType]
	return ok
}

// ResetRunnerType resets all changes to the "runner_type" field.
func (m *WorkflowRunMutation) ResetRunnerType() {
	m.runner_type = nil
	delete(m.clearedFields, workflowrun.FieldRunnerType)
}

// SetAttestation sets the "attestation" field.
func (m *WorkflowRunMutation) SetAttestation(d *dsse.Envelope) {
	m.attestation = &d
}

// Attestation returns the value of the "attestation" field in the mutation.
func (m *WorkflowRunMutation) Attestation() (r *dsse.Envelope, exists bool) {
	v := m.attestation
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestation returns the old "attestation" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldAttestation(ctx context.Context) (v *dsse.Envelope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestation: %w", err)
	}
	return oldValue.Attestation, nil
}

// ClearAttestation clears the value of the "attestation" field.
func (m *WorkflowRunMutation) ClearAttestation() {
	m.attestation = nil
	m.clearedFields[workflowrun.FieldAttestation] = struct{}{}
}

// AttestationCleared returns if the "attestation" field was cleared in this mutation.
func (m *WorkflowRunMutation) AttestationCleared() bool {
	_, ok := m.clearedFields[workflowrun.FieldAttestation]
	return ok
}

// ResetAttestation resets all changes to the "attestation" field.
func (m *WorkflowRunMutation) ResetAttestation() {
	m.attestation = nil
	delete(m.clearedFields, workflowrun.FieldAttestation)
}

// SetAttestationDigest sets the "attestation_digest" field.
func (m *WorkflowRunMutation) SetAttestationDigest(s string) {
	m.attestation_digest = &s
}

// AttestationDigest returns the value of the "attestation_digest" field in the mutation.
func (m *WorkflowRunMutation) AttestationDigest() (r string, exists bool) {
	v := m.attestation_digest
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestationDigest returns the old "attestation_digest" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldAttestationDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestationDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestationDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestationDigest: %w", err)
	}
	return oldValue.AttestationDigest, nil
}

// ClearAttestationDigest clears the value of the "attestation_digest" field.
func (m *WorkflowRunMutation) ClearAttestationDigest() {
	m.attestation_digest = nil
	m.clearedFields[workflowrun.FieldAttestationDigest] = struct{}{}
}

// AttestationDigestCleared returns if the "attestation_digest" field was cleared in this mutation.
func (m *WorkflowRunMutation) AttestationDigestCleared() bool {
	_, ok := m.clearedFields[workflowrun.FieldAttestationDigest]
	return ok
}

// ResetAttestationDigest resets all changes to the "attestation_digest" field.
func (m *WorkflowRunMutation) ResetAttestationDigest() {
	m.attestation_digest = nil
	delete(m.clearedFields, workflowrun.FieldAttestationDigest)
}

// SetAttestationState sets the "attestation_state" field.
func (m *WorkflowRunMutation) SetAttestationState(b []byte) {
	m.attestation_state = &b
}

// AttestationState returns the value of the "attestation_state" field in the mutation.
func (m *WorkflowRunMutation) AttestationState() (r []byte, exists bool) {
	v := m.attestation_state
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestationState returns the old "attestation_state" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldAttestationState(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestationState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestationState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestationState: %w", err)
	}
	return oldValue.AttestationState, nil
}

// ClearAttestationState clears the value of the "attestation_state" field.
func (m *WorkflowRunMutation) ClearAttestationState() {
	m.attestation_state = nil
	m.clearedFields[workflowrun.FieldAttestationState] = struct{}{}
}

// AttestationStateCleared returns if the "attestation_state" field was cleared in this mutation.
func (m *WorkflowRunMutation) AttestationStateCleared() bool {
	_, ok := m.clearedFields[workflowrun.FieldAttestationState]
	return ok
}

// ResetAttestationState resets all changes to the "attestation_state" field.
func (m *WorkflowRunMutation) ResetAttestationState() {
	m.attestation_state = nil
	delete(m.clearedFields, workflowrun.FieldAttestationState)
}

// SetContractRevisionUsed sets the "contract_revision_used" field.
func (m *WorkflowRunMutation) SetContractRevisionUsed(i int) {
	m.contract_revision_used = &i
	m.addcontract_revision_used = nil
}

// ContractRevisionUsed returns the value of the "contract_revision_used" field in the mutation.
func (m *WorkflowRunMutation) ContractRevisionUsed() (r int, exists bool) {
	v := m.contract_revision_used
	if v == nil {
		return
	}
	return *v, true
}

// OldContractRevisionUsed returns the old "contract_revision_used" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldContractRevisionUsed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractRevisionUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractRevisionUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractRevisionUsed: %w", err)
	}
	return oldValue.ContractRevisionUsed, nil
}

// AddContractRevisionUsed adds i to the "contract_revision_used" field.
func (m *WorkflowRunMutation) AddContractRevisionUsed(i int) {
	if m.addcontract_revision_used != nil {
		*m.addcontract_revision_used += i
	} else {
		m.addcontract_revision_used = &i
	}
}

// AddedContractRevisionUsed returns the value that was added to the "contract_revision_used" field in this mutation.
func (m *WorkflowRunMutation) AddedContractRevisionUsed() (r int, exists bool) {
	v := m.addcontract_revision_used
	if v == nil {
		return
	}
	return *v, true
}

// ResetContractRevisionUsed resets all changes to the "contract_revision_used" field.
func (m *WorkflowRunMutation) ResetContractRevisionUsed() {
	m.contract_revision_used = nil
	m.addcontract_revision_used = nil
}

// SetContractRevisionLatest sets the "contract_revision_latest" field.
func (m *WorkflowRunMutation) SetContractRevisionLatest(i int) {
	m.contract_revision_latest = &i
	m.addcontract_revision_latest = nil
}

// ContractRevisionLatest returns the value of the "contract_revision_latest" field in the mutation.
func (m *WorkflowRunMutation) ContractRevisionLatest() (r int, exists bool) {
	v := m.contract_revision_latest
	if v == nil {
		return
	}
	return *v, true
}

// OldContractRevisionLatest returns the old "contract_revision_latest" field's value of the WorkflowRun entity.
// If the WorkflowRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowRunMutation) OldContractRevisionLatest(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractRevisionLatest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractRevisionLatest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractRevisionLatest: %w", err)
	}
	return oldValue.ContractRevisionLatest, nil
}

// AddContractRevisionLatest adds i to the "contract_revision_latest" field.
func (m *WorkflowRunMutation) AddContractRevisionLatest(i int) {
	if m.addcontract_revision_latest != nil {
		*m.addcontract_revision_latest += i
	} else {
		m.addcontract_revision_latest = &i
	}
}

// AddedContractRevisionLatest returns the value that was added to the "contract_revision_latest" field in this mutation.
func (m *WorkflowRunMutation) AddedContractRevisionLatest() (r int, exists bool) {
	v := m.addcontract_revision_latest
	if v == nil {
		return
	}
	return *v, true
}

// ResetContractRevisionLatest resets all changes to the "contract_revision_latest" field.
func (m *WorkflowRunMutation) ResetContractRevisionLatest() {
	m.contract_revision_latest = nil
	m.addcontract_revision_latest = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *WorkflowRunMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *WorkflowRunMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *WorkflowRunMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *WorkflowRunMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowRunMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowRunMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetRobotaccountID sets the "robotaccount" edge to the RobotAccount entity by id.
func (m *WorkflowRunMutation) SetRobotaccountID(id uuid.UUID) {
	m.robotaccount = &id
}

// ClearRobotaccount clears the "robotaccount" edge to the RobotAccount entity.
func (m *WorkflowRunMutation) ClearRobotaccount() {
	m.clearedrobotaccount = true
}

// RobotaccountCleared reports if the "robotaccount" edge to the RobotAccount entity was cleared.
func (m *WorkflowRunMutation) RobotaccountCleared() bool {
	return m.clearedrobotaccount
}

// RobotaccountID returns the "robotaccount" edge ID in the mutation.
func (m *WorkflowRunMutation) RobotaccountID() (id uuid.UUID, exists bool) {
	if m.robotaccount != nil {
		return *m.robotaccount, true
	}
	return
}

// RobotaccountIDs returns the "robotaccount" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RobotaccountID instead. It exists only for internal usage by the builders.
func (m *WorkflowRunMutation) RobotaccountIDs() (ids []uuid.UUID) {
	if id := m.robotaccount; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRobotaccount resets all changes to the "robotaccount" edge.
func (m *WorkflowRunMutation) ResetRobotaccount() {
	m.robotaccount = nil
	m.clearedrobotaccount = false
}

// SetContractVersionID sets the "contract_version" edge to the WorkflowContractVersion entity by id.
func (m *WorkflowRunMutation) SetContractVersionID(id uuid.UUID) {
	m.contract_version = &id
}

// ClearContractVersion clears the "contract_version" edge to the WorkflowContractVersion entity.
func (m *WorkflowRunMutation) ClearContractVersion() {
	m.clearedcontract_version = true
}

// ContractVersionCleared reports if the "contract_version" edge to the WorkflowContractVersion entity was cleared.
func (m *WorkflowRunMutation) ContractVersionCleared() bool {
	return m.clearedcontract_version
}

// ContractVersionID returns the "contract_version" edge ID in the mutation.
func (m *WorkflowRunMutation) ContractVersionID() (id uuid.UUID, exists bool) {
	if m.contract_version != nil {
		return *m.contract_version, true
	}
	return
}

// ContractVersionIDs returns the "contract_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractVersionID instead. It exists only for internal usage by the builders.
func (m *WorkflowRunMutation) ContractVersionIDs() (ids []uuid.UUID) {
	if id := m.contract_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContractVersion resets all changes to the "contract_version" edge.
func (m *WorkflowRunMutation) ResetContractVersion() {
	m.contract_version = nil
	m.clearedcontract_version = false
}

// AddCasBackendIDs adds the "cas_backends" edge to the CASBackend entity by ids.
func (m *WorkflowRunMutation) AddCasBackendIDs(ids ...uuid.UUID) {
	if m.cas_backends == nil {
		m.cas_backends = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cas_backends[ids[i]] = struct{}{}
	}
}

// ClearCasBackends clears the "cas_backends" edge to the CASBackend entity.
func (m *WorkflowRunMutation) ClearCasBackends() {
	m.clearedcas_backends = true
}

// CasBackendsCleared reports if the "cas_backends" edge to the CASBackend entity was cleared.
func (m *WorkflowRunMutation) CasBackendsCleared() bool {
	return m.clearedcas_backends
}

// RemoveCasBackendIDs removes the "cas_backends" edge to the CASBackend entity by IDs.
func (m *WorkflowRunMutation) RemoveCasBackendIDs(ids ...uuid.UUID) {
	if m.removedcas_backends == nil {
		m.removedcas_backends = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cas_backends, ids[i])
		m.removedcas_backends[ids[i]] = struct{}{}
	}
}

// RemovedCasBackends returns the removed IDs of the "cas_backends" edge to the CASBackend entity.
func (m *WorkflowRunMutation) RemovedCasBackendsIDs() (ids []uuid.UUID) {
	for id := range m.removedcas_backends {
		ids = append(ids, id)
	}
	return
}

// CasBackendsIDs returns the "cas_backends" edge IDs in the mutation.
func (m *WorkflowRunMutation) CasBackendsIDs() (ids []uuid.UUID) {
	for id := range m.cas_backends {
		ids = append(ids, id)
	}
	return
}

// ResetCasBackends resets all changes to the "cas_backends" edge.
func (m *WorkflowRunMutation) ResetCasBackends() {
	m.cas_backends = nil
	m.clearedcas_backends = false
	m.removedcas_backends = nil
}

// Where appends a list predicates to the WorkflowRunMutation builder.
func (m *WorkflowRunMutation) Where(ps ...predicate.WorkflowRun) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowRunMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowRunMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowRun, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowRunMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowRunMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowRun).
func (m *WorkflowRunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowRunMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, workflowrun.FieldCreatedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, workflowrun.FieldFinishedAt)
	}
	if m.state != nil {
		fields = append(fields, workflowrun.FieldState)
	}
	if m.reason != nil {
		fields = append(fields, workflowrun.FieldReason)
	}
	if m.run_url != nil {
		fields = append(fields, workflowrun.FieldRunURL)
	}
	if m.runner_type != nil {
		fields = append(fields, workflowrun.FieldRunnerType)
	}
	if m.attestation != nil {
		fields = append(fields, workflowrun.FieldAttestation)
	}
	if m.attestation_digest != nil {
		fields = append(fields, workflowrun.FieldAttestationDigest)
	}
	if m.attestation_state != nil {
		fields = append(fields, workflowrun.FieldAttestationState)
	}
	if m.contract_revision_used != nil {
		fields = append(fields, workflowrun.FieldContractRevisionUsed)
	}
	if m.contract_revision_latest != nil {
		fields = append(fields, workflowrun.FieldContractRevisionLatest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowRunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowrun.FieldCreatedAt:
		return m.CreatedAt()
	case workflowrun.FieldFinishedAt:
		return m.FinishedAt()
	case workflowrun.FieldState:
		return m.State()
	case workflowrun.FieldReason:
		return m.Reason()
	case workflowrun.FieldRunURL:
		return m.RunURL()
	case workflowrun.FieldRunnerType:
		return m.RunnerType()
	case workflowrun.FieldAttestation:
		return m.Attestation()
	case workflowrun.FieldAttestationDigest:
		return m.AttestationDigest()
	case workflowrun.FieldAttestationState:
		return m.AttestationState()
	case workflowrun.FieldContractRevisionUsed:
		return m.ContractRevisionUsed()
	case workflowrun.FieldContractRevisionLatest:
		return m.ContractRevisionLatest()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowRunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowrun.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowrun.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case workflowrun.FieldState:
		return m.OldState(ctx)
	case workflowrun.FieldReason:
		return m.OldReason(ctx)
	case workflowrun.FieldRunURL:
		return m.OldRunURL(ctx)
	case workflowrun.FieldRunnerType:
		return m.OldRunnerType(ctx)
	case workflowrun.FieldAttestation:
		return m.OldAttestation(ctx)
	case workflowrun.FieldAttestationDigest:
		return m.OldAttestationDigest(ctx)
	case workflowrun.FieldAttestationState:
		return m.OldAttestationState(ctx)
	case workflowrun.FieldContractRevisionUsed:
		return m.OldContractRevisionUsed(ctx)
	case workflowrun.FieldContractRevisionLatest:
		return m.OldContractRevisionLatest(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowRun field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowRunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowrun.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowrun.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case workflowrun.FieldState:
		v, ok := value.(biz.WorkflowRunStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case workflowrun.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case workflowrun.FieldRunURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunURL(v)
		return nil
	case workflowrun.FieldRunnerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunnerType(v)
		return nil
	case workflowrun.FieldAttestation:
		v, ok := value.(*dsse.Envelope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestation(v)
		return nil
	case workflowrun.FieldAttestationDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestationDigest(v)
		return nil
	case workflowrun.FieldAttestationState:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestationState(v)
		return nil
	case workflowrun.FieldContractRevisionUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractRevisionUsed(v)
		return nil
	case workflowrun.FieldContractRevisionLatest:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractRevisionLatest(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowRun field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowRunMutation) AddedFields() []string {
	var fields []string
	if m.addcontract_revision_used != nil {
		fields = append(fields, workflowrun.FieldContractRevisionUsed)
	}
	if m.addcontract_revision_latest != nil {
		fields = append(fields, workflowrun.FieldContractRevisionLatest)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowRunMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowrun.FieldContractRevisionUsed:
		return m.AddedContractRevisionUsed()
	case workflowrun.FieldContractRevisionLatest:
		return m.AddedContractRevisionLatest()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowRunMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowrun.FieldContractRevisionUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContractRevisionUsed(v)
		return nil
	case workflowrun.FieldContractRevisionLatest:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContractRevisionLatest(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowRun numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowRunMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowrun.FieldFinishedAt) {
		fields = append(fields, workflowrun.FieldFinishedAt)
	}
	if m.FieldCleared(workflowrun.FieldReason) {
		fields = append(fields, workflowrun.FieldReason)
	}
	if m.FieldCleared(workflowrun.FieldRunURL) {
		fields = append(fields, workflowrun.FieldRunURL)
	}
	if m.FieldCleared(workflowrun.FieldRunnerType) {
		fields = append(fields, workflowrun.FieldRunnerType)
	}
	if m.FieldCleared(workflowrun.FieldAttestation) {
		fields = append(fields, workflowrun.FieldAttestation)
	}
	if m.FieldCleared(workflowrun.FieldAttestationDigest) {
		fields = append(fields, workflowrun.FieldAttestationDigest)
	}
	if m.FieldCleared(workflowrun.FieldAttestationState) {
		fields = append(fields, workflowrun.FieldAttestationState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowRunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowRunMutation) ClearField(name string) error {
	switch name {
	case workflowrun.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case workflowrun.FieldReason:
		m.ClearReason()
		return nil
	case workflowrun.FieldRunURL:
		m.ClearRunURL()
		return nil
	case workflowrun.FieldRunnerType:
		m.ClearRunnerType()
		return nil
	case workflowrun.FieldAttestation:
		m.ClearAttestation()
		return nil
	case workflowrun.FieldAttestationDigest:
		m.ClearAttestationDigest()
		return nil
	case workflowrun.FieldAttestationState:
		m.ClearAttestationState()
		return nil
	}
	return fmt.Errorf("unknown WorkflowRun nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowRunMutation) ResetField(name string) error {
	switch name {
	case workflowrun.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowrun.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case workflowrun.FieldState:
		m.ResetState()
		return nil
	case workflowrun.FieldReason:
		m.ResetReason()
		return nil
	case workflowrun.FieldRunURL:
		m.ResetRunURL()
		return nil
	case workflowrun.FieldRunnerType:
		m.ResetRunnerType()
		return nil
	case workflowrun.FieldAttestation:
		m.ResetAttestation()
		return nil
	case workflowrun.FieldAttestationDigest:
		m.ResetAttestationDigest()
		return nil
	case workflowrun.FieldAttestationState:
		m.ResetAttestationState()
		return nil
	case workflowrun.FieldContractRevisionUsed:
		m.ResetContractRevisionUsed()
		return nil
	case workflowrun.FieldContractRevisionLatest:
		m.ResetContractRevisionLatest()
		return nil
	}
	return fmt.Errorf("unknown WorkflowRun field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowRunMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.workflow != nil {
		edges = append(edges, workflowrun.EdgeWorkflow)
	}
	if m.robotaccount != nil {
		edges = append(edges, workflowrun.EdgeRobotaccount)
	}
	if m.contract_version != nil {
		edges = append(edges, workflowrun.EdgeContractVersion)
	}
	if m.cas_backends != nil {
		edges = append(edges, workflowrun.EdgeCasBackends)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowRunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowrun.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case workflowrun.EdgeRobotaccount:
		if id := m.robotaccount; id != nil {
			return []ent.Value{*id}
		}
	case workflowrun.EdgeContractVersion:
		if id := m.contract_version; id != nil {
			return []ent.Value{*id}
		}
	case workflowrun.EdgeCasBackends:
		ids := make([]ent.Value, 0, len(m.cas_backends))
		for id := range m.cas_backends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowRunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcas_backends != nil {
		edges = append(edges, workflowrun.EdgeCasBackends)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowRunMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflowrun.EdgeCasBackends:
		ids := make([]ent.Value, 0, len(m.removedcas_backends))
		for id := range m.removedcas_backends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowRunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedworkflow {
		edges = append(edges, workflowrun.EdgeWorkflow)
	}
	if m.clearedrobotaccount {
		edges = append(edges, workflowrun.EdgeRobotaccount)
	}
	if m.clearedcontract_version {
		edges = append(edges, workflowrun.EdgeContractVersion)
	}
	if m.clearedcas_backends {
		edges = append(edges, workflowrun.EdgeCasBackends)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowRunMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowrun.EdgeWorkflow:
		return m.clearedworkflow
	case workflowrun.EdgeRobotaccount:
		return m.clearedrobotaccount
	case workflowrun.EdgeContractVersion:
		return m.clearedcontract_version
	case workflowrun.EdgeCasBackends:
		return m.clearedcas_backends
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowRunMutation) ClearEdge(name string) error {
	switch name {
	case workflowrun.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case workflowrun.EdgeRobotaccount:
		m.ClearRobotaccount()
		return nil
	case workflowrun.EdgeContractVersion:
		m.ClearContractVersion()
		return nil
	}
	return fmt.Errorf("unknown WorkflowRun unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowRunMutation) ResetEdge(name string) error {
	switch name {
	case workflowrun.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case workflowrun.EdgeRobotaccount:
		m.ResetRobotaccount()
		return nil
	case workflowrun.EdgeContractVersion:
		m.ResetContractVersion()
		return nil
	case workflowrun.EdgeCasBackends:
		m.ResetCasBackends()
		return nil
	}
	return fmt.Errorf("unknown WorkflowRun edge %s", name)
}
