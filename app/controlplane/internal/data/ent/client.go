// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/casbackend"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/casmapping"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/integration"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/integrationattachment"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/membership"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/organization"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/orginvitation"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/robotaccount"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/user"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/workflow"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/workflowcontract"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/workflowcontractversion"
	"github.com/chainloop-dev/chainloop/app/controlplane/internal/data/ent/workflowrun"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// CASBackend is the client for interacting with the CASBackend builders.
	CASBackend *CASBackendClient
	// CASMapping is the client for interacting with the CASMapping builders.
	CASMapping *CASMappingClient
	// Integration is the client for interacting with the Integration builders.
	Integration *IntegrationClient
	// IntegrationAttachment is the client for interacting with the IntegrationAttachment builders.
	IntegrationAttachment *IntegrationAttachmentClient
	// Membership is the client for interacting with the Membership builders.
	Membership *MembershipClient
	// OrgInvitation is the client for interacting with the OrgInvitation builders.
	OrgInvitation *OrgInvitationClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// RobotAccount is the client for interacting with the RobotAccount builders.
	RobotAccount *RobotAccountClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// Workflow is the client for interacting with the Workflow builders.
	Workflow *WorkflowClient
	// WorkflowContract is the client for interacting with the WorkflowContract builders.
	WorkflowContract *WorkflowContractClient
	// WorkflowContractVersion is the client for interacting with the WorkflowContractVersion builders.
	WorkflowContractVersion *WorkflowContractVersionClient
	// WorkflowRun is the client for interacting with the WorkflowRun builders.
	WorkflowRun *WorkflowRunClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.CASBackend = NewCASBackendClient(c.config)
	c.CASMapping = NewCASMappingClient(c.config)
	c.Integration = NewIntegrationClient(c.config)
	c.IntegrationAttachment = NewIntegrationAttachmentClient(c.config)
	c.Membership = NewMembershipClient(c.config)
	c.OrgInvitation = NewOrgInvitationClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.RobotAccount = NewRobotAccountClient(c.config)
	c.User = NewUserClient(c.config)
	c.Workflow = NewWorkflowClient(c.config)
	c.WorkflowContract = NewWorkflowContractClient(c.config)
	c.WorkflowContractVersion = NewWorkflowContractVersionClient(c.config)
	c.WorkflowRun = NewWorkflowRunClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		CASBackend:              NewCASBackendClient(cfg),
		CASMapping:              NewCASMappingClient(cfg),
		Integration:             NewIntegrationClient(cfg),
		IntegrationAttachment:   NewIntegrationAttachmentClient(cfg),
		Membership:              NewMembershipClient(cfg),
		OrgInvitation:           NewOrgInvitationClient(cfg),
		Organization:            NewOrganizationClient(cfg),
		RobotAccount:            NewRobotAccountClient(cfg),
		User:                    NewUserClient(cfg),
		Workflow:                NewWorkflowClient(cfg),
		WorkflowContract:        NewWorkflowContractClient(cfg),
		WorkflowContractVersion: NewWorkflowContractVersionClient(cfg),
		WorkflowRun:             NewWorkflowRunClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		CASBackend:              NewCASBackendClient(cfg),
		CASMapping:              NewCASMappingClient(cfg),
		Integration:             NewIntegrationClient(cfg),
		IntegrationAttachment:   NewIntegrationAttachmentClient(cfg),
		Membership:              NewMembershipClient(cfg),
		OrgInvitation:           NewOrgInvitationClient(cfg),
		Organization:            NewOrganizationClient(cfg),
		RobotAccount:            NewRobotAccountClient(cfg),
		User:                    NewUserClient(cfg),
		Workflow:                NewWorkflowClient(cfg),
		WorkflowContract:        NewWorkflowContractClient(cfg),
		WorkflowContractVersion: NewWorkflowContractVersionClient(cfg),
		WorkflowRun:             NewWorkflowRunClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		CASBackend.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.CASBackend, c.CASMapping, c.Integration, c.IntegrationAttachment,
		c.Membership, c.OrgInvitation, c.Organization, c.RobotAccount, c.User,
		c.Workflow, c.WorkflowContract, c.WorkflowContractVersion, c.WorkflowRun,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.CASBackend, c.CASMapping, c.Integration, c.IntegrationAttachment,
		c.Membership, c.OrgInvitation, c.Organization, c.RobotAccount, c.User,
		c.Workflow, c.WorkflowContract, c.WorkflowContractVersion, c.WorkflowRun,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CASBackendMutation:
		return c.CASBackend.mutate(ctx, m)
	case *CASMappingMutation:
		return c.CASMapping.mutate(ctx, m)
	case *IntegrationMutation:
		return c.Integration.mutate(ctx, m)
	case *IntegrationAttachmentMutation:
		return c.IntegrationAttachment.mutate(ctx, m)
	case *MembershipMutation:
		return c.Membership.mutate(ctx, m)
	case *OrgInvitationMutation:
		return c.OrgInvitation.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *RobotAccountMutation:
		return c.RobotAccount.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *WorkflowMutation:
		return c.Workflow.mutate(ctx, m)
	case *WorkflowContractMutation:
		return c.WorkflowContract.mutate(ctx, m)
	case *WorkflowContractVersionMutation:
		return c.WorkflowContractVersion.mutate(ctx, m)
	case *WorkflowRunMutation:
		return c.WorkflowRun.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CASBackendClient is a client for the CASBackend schema.
type CASBackendClient struct {
	config
}

// NewCASBackendClient returns a client for the CASBackend from the given config.
func NewCASBackendClient(c config) *CASBackendClient {
	return &CASBackendClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `casbackend.Hooks(f(g(h())))`.
func (c *CASBackendClient) Use(hooks ...Hook) {
	c.hooks.CASBackend = append(c.hooks.CASBackend, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `casbackend.Intercept(f(g(h())))`.
func (c *CASBackendClient) Intercept(interceptors ...Interceptor) {
	c.inters.CASBackend = append(c.inters.CASBackend, interceptors...)
}

// Create returns a builder for creating a CASBackend entity.
func (c *CASBackendClient) Create() *CASBackendCreate {
	mutation := newCASBackendMutation(c.config, OpCreate)
	return &CASBackendCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CASBackend entities.
func (c *CASBackendClient) CreateBulk(builders ...*CASBackendCreate) *CASBackendCreateBulk {
	return &CASBackendCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CASBackend.
func (c *CASBackendClient) Update() *CASBackendUpdate {
	mutation := newCASBackendMutation(c.config, OpUpdate)
	return &CASBackendUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CASBackendClient) UpdateOne(cb *CASBackend) *CASBackendUpdateOne {
	mutation := newCASBackendMutation(c.config, OpUpdateOne, withCASBackend(cb))
	return &CASBackendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CASBackendClient) UpdateOneID(id uuid.UUID) *CASBackendUpdateOne {
	mutation := newCASBackendMutation(c.config, OpUpdateOne, withCASBackendID(id))
	return &CASBackendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CASBackend.
func (c *CASBackendClient) Delete() *CASBackendDelete {
	mutation := newCASBackendMutation(c.config, OpDelete)
	return &CASBackendDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CASBackendClient) DeleteOne(cb *CASBackend) *CASBackendDeleteOne {
	return c.DeleteOneID(cb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CASBackendClient) DeleteOneID(id uuid.UUID) *CASBackendDeleteOne {
	builder := c.Delete().Where(casbackend.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CASBackendDeleteOne{builder}
}

// Query returns a query builder for CASBackend.
func (c *CASBackendClient) Query() *CASBackendQuery {
	return &CASBackendQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCASBackend},
		inters: c.Interceptors(),
	}
}

// Get returns a CASBackend entity by its id.
func (c *CASBackendClient) Get(ctx context.Context, id uuid.UUID) (*CASBackend, error) {
	return c.Query().Where(casbackend.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CASBackendClient) GetX(ctx context.Context, id uuid.UUID) *CASBackend {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a CASBackend.
func (c *CASBackendClient) QueryOrganization(cb *CASBackend) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(casbackend.Table, casbackend.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, casbackend.OrganizationTable, casbackend.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowRun queries the workflow_run edge of a CASBackend.
func (c *CASBackendClient) QueryWorkflowRun(cb *CASBackend) *WorkflowRunQuery {
	query := (&WorkflowRunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(casbackend.Table, casbackend.FieldID, id),
			sqlgraph.To(workflowrun.Table, workflowrun.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, casbackend.WorkflowRunTable, casbackend.WorkflowRunPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CASBackendClient) Hooks() []Hook {
	return c.hooks.CASBackend
}

// Interceptors returns the client interceptors.
func (c *CASBackendClient) Interceptors() []Interceptor {
	return c.inters.CASBackend
}

func (c *CASBackendClient) mutate(ctx context.Context, m *CASBackendMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CASBackendCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CASBackendUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CASBackendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CASBackendDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CASBackend mutation op: %q", m.Op())
	}
}

// CASMappingClient is a client for the CASMapping schema.
type CASMappingClient struct {
	config
}

// NewCASMappingClient returns a client for the CASMapping from the given config.
func NewCASMappingClient(c config) *CASMappingClient {
	return &CASMappingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `casmapping.Hooks(f(g(h())))`.
func (c *CASMappingClient) Use(hooks ...Hook) {
	c.hooks.CASMapping = append(c.hooks.CASMapping, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `casmapping.Intercept(f(g(h())))`.
func (c *CASMappingClient) Intercept(interceptors ...Interceptor) {
	c.inters.CASMapping = append(c.inters.CASMapping, interceptors...)
}

// Create returns a builder for creating a CASMapping entity.
func (c *CASMappingClient) Create() *CASMappingCreate {
	mutation := newCASMappingMutation(c.config, OpCreate)
	return &CASMappingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CASMapping entities.
func (c *CASMappingClient) CreateBulk(builders ...*CASMappingCreate) *CASMappingCreateBulk {
	return &CASMappingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CASMapping.
func (c *CASMappingClient) Update() *CASMappingUpdate {
	mutation := newCASMappingMutation(c.config, OpUpdate)
	return &CASMappingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CASMappingClient) UpdateOne(cm *CASMapping) *CASMappingUpdateOne {
	mutation := newCASMappingMutation(c.config, OpUpdateOne, withCASMapping(cm))
	return &CASMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CASMappingClient) UpdateOneID(id uuid.UUID) *CASMappingUpdateOne {
	mutation := newCASMappingMutation(c.config, OpUpdateOne, withCASMappingID(id))
	return &CASMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CASMapping.
func (c *CASMappingClient) Delete() *CASMappingDelete {
	mutation := newCASMappingMutation(c.config, OpDelete)
	return &CASMappingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CASMappingClient) DeleteOne(cm *CASMapping) *CASMappingDeleteOne {
	return c.DeleteOneID(cm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CASMappingClient) DeleteOneID(id uuid.UUID) *CASMappingDeleteOne {
	builder := c.Delete().Where(casmapping.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CASMappingDeleteOne{builder}
}

// Query returns a query builder for CASMapping.
func (c *CASMappingClient) Query() *CASMappingQuery {
	return &CASMappingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCASMapping},
		inters: c.Interceptors(),
	}
}

// Get returns a CASMapping entity by its id.
func (c *CASMappingClient) Get(ctx context.Context, id uuid.UUID) (*CASMapping, error) {
	return c.Query().Where(casmapping.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CASMappingClient) GetX(ctx context.Context, id uuid.UUID) *CASMapping {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCasBackend queries the cas_backend edge of a CASMapping.
func (c *CASMappingClient) QueryCasBackend(cm *CASMapping) *CASBackendQuery {
	query := (&CASBackendClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(casmapping.Table, casmapping.FieldID, id),
			sqlgraph.To(casbackend.Table, casbackend.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, casmapping.CasBackendTable, casmapping.CasBackendColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowRun queries the workflow_run edge of a CASMapping.
func (c *CASMappingClient) QueryWorkflowRun(cm *CASMapping) *WorkflowRunQuery {
	query := (&WorkflowRunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(casmapping.Table, casmapping.FieldID, id),
			sqlgraph.To(workflowrun.Table, workflowrun.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, casmapping.WorkflowRunTable, casmapping.WorkflowRunColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a CASMapping.
func (c *CASMappingClient) QueryOrganization(cm *CASMapping) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(casmapping.Table, casmapping.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, casmapping.OrganizationTable, casmapping.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CASMappingClient) Hooks() []Hook {
	return c.hooks.CASMapping
}

// Interceptors returns the client interceptors.
func (c *CASMappingClient) Interceptors() []Interceptor {
	return c.inters.CASMapping
}

func (c *CASMappingClient) mutate(ctx context.Context, m *CASMappingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CASMappingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CASMappingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CASMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CASMappingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CASMapping mutation op: %q", m.Op())
	}
}

// IntegrationClient is a client for the Integration schema.
type IntegrationClient struct {
	config
}

// NewIntegrationClient returns a client for the Integration from the given config.
func NewIntegrationClient(c config) *IntegrationClient {
	return &IntegrationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `integration.Hooks(f(g(h())))`.
func (c *IntegrationClient) Use(hooks ...Hook) {
	c.hooks.Integration = append(c.hooks.Integration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `integration.Intercept(f(g(h())))`.
func (c *IntegrationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Integration = append(c.inters.Integration, interceptors...)
}

// Create returns a builder for creating a Integration entity.
func (c *IntegrationClient) Create() *IntegrationCreate {
	mutation := newIntegrationMutation(c.config, OpCreate)
	return &IntegrationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Integration entities.
func (c *IntegrationClient) CreateBulk(builders ...*IntegrationCreate) *IntegrationCreateBulk {
	return &IntegrationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Integration.
func (c *IntegrationClient) Update() *IntegrationUpdate {
	mutation := newIntegrationMutation(c.config, OpUpdate)
	return &IntegrationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntegrationClient) UpdateOne(i *Integration) *IntegrationUpdateOne {
	mutation := newIntegrationMutation(c.config, OpUpdateOne, withIntegration(i))
	return &IntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntegrationClient) UpdateOneID(id uuid.UUID) *IntegrationUpdateOne {
	mutation := newIntegrationMutation(c.config, OpUpdateOne, withIntegrationID(id))
	return &IntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Integration.
func (c *IntegrationClient) Delete() *IntegrationDelete {
	mutation := newIntegrationMutation(c.config, OpDelete)
	return &IntegrationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntegrationClient) DeleteOne(i *Integration) *IntegrationDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntegrationClient) DeleteOneID(id uuid.UUID) *IntegrationDeleteOne {
	builder := c.Delete().Where(integration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntegrationDeleteOne{builder}
}

// Query returns a query builder for Integration.
func (c *IntegrationClient) Query() *IntegrationQuery {
	return &IntegrationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntegration},
		inters: c.Interceptors(),
	}
}

// Get returns a Integration entity by its id.
func (c *IntegrationClient) Get(ctx context.Context, id uuid.UUID) (*Integration, error) {
	return c.Query().Where(integration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntegrationClient) GetX(ctx context.Context, id uuid.UUID) *Integration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttachments queries the attachments edge of a Integration.
func (c *IntegrationClient) QueryAttachments(i *Integration) *IntegrationAttachmentQuery {
	query := (&IntegrationAttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(integrationattachment.Table, integrationattachment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, integration.AttachmentsTable, integration.AttachmentsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a Integration.
func (c *IntegrationClient) QueryOrganization(i *Integration) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, integration.OrganizationTable, integration.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IntegrationClient) Hooks() []Hook {
	return c.hooks.Integration
}

// Interceptors returns the client interceptors.
func (c *IntegrationClient) Interceptors() []Interceptor {
	return c.inters.Integration
}

func (c *IntegrationClient) mutate(ctx context.Context, m *IntegrationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntegrationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntegrationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntegrationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Integration mutation op: %q", m.Op())
	}
}

// IntegrationAttachmentClient is a client for the IntegrationAttachment schema.
type IntegrationAttachmentClient struct {
	config
}

// NewIntegrationAttachmentClient returns a client for the IntegrationAttachment from the given config.
func NewIntegrationAttachmentClient(c config) *IntegrationAttachmentClient {
	return &IntegrationAttachmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `integrationattachment.Hooks(f(g(h())))`.
func (c *IntegrationAttachmentClient) Use(hooks ...Hook) {
	c.hooks.IntegrationAttachment = append(c.hooks.IntegrationAttachment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `integrationattachment.Intercept(f(g(h())))`.
func (c *IntegrationAttachmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.IntegrationAttachment = append(c.inters.IntegrationAttachment, interceptors...)
}

// Create returns a builder for creating a IntegrationAttachment entity.
func (c *IntegrationAttachmentClient) Create() *IntegrationAttachmentCreate {
	mutation := newIntegrationAttachmentMutation(c.config, OpCreate)
	return &IntegrationAttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IntegrationAttachment entities.
func (c *IntegrationAttachmentClient) CreateBulk(builders ...*IntegrationAttachmentCreate) *IntegrationAttachmentCreateBulk {
	return &IntegrationAttachmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IntegrationAttachment.
func (c *IntegrationAttachmentClient) Update() *IntegrationAttachmentUpdate {
	mutation := newIntegrationAttachmentMutation(c.config, OpUpdate)
	return &IntegrationAttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntegrationAttachmentClient) UpdateOne(ia *IntegrationAttachment) *IntegrationAttachmentUpdateOne {
	mutation := newIntegrationAttachmentMutation(c.config, OpUpdateOne, withIntegrationAttachment(ia))
	return &IntegrationAttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntegrationAttachmentClient) UpdateOneID(id uuid.UUID) *IntegrationAttachmentUpdateOne {
	mutation := newIntegrationAttachmentMutation(c.config, OpUpdateOne, withIntegrationAttachmentID(id))
	return &IntegrationAttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IntegrationAttachment.
func (c *IntegrationAttachmentClient) Delete() *IntegrationAttachmentDelete {
	mutation := newIntegrationAttachmentMutation(c.config, OpDelete)
	return &IntegrationAttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntegrationAttachmentClient) DeleteOne(ia *IntegrationAttachment) *IntegrationAttachmentDeleteOne {
	return c.DeleteOneID(ia.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntegrationAttachmentClient) DeleteOneID(id uuid.UUID) *IntegrationAttachmentDeleteOne {
	builder := c.Delete().Where(integrationattachment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntegrationAttachmentDeleteOne{builder}
}

// Query returns a query builder for IntegrationAttachment.
func (c *IntegrationAttachmentClient) Query() *IntegrationAttachmentQuery {
	return &IntegrationAttachmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntegrationAttachment},
		inters: c.Interceptors(),
	}
}

// Get returns a IntegrationAttachment entity by its id.
func (c *IntegrationAttachmentClient) Get(ctx context.Context, id uuid.UUID) (*IntegrationAttachment, error) {
	return c.Query().Where(integrationattachment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntegrationAttachmentClient) GetX(ctx context.Context, id uuid.UUID) *IntegrationAttachment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIntegration queries the integration edge of a IntegrationAttachment.
func (c *IntegrationAttachmentClient) QueryIntegration(ia *IntegrationAttachment) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ia.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integrationattachment.Table, integrationattachment.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, integrationattachment.IntegrationTable, integrationattachment.IntegrationColumn),
		)
		fromV = sqlgraph.Neighbors(ia.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflow queries the workflow edge of a IntegrationAttachment.
func (c *IntegrationAttachmentClient) QueryWorkflow(ia *IntegrationAttachment) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ia.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integrationattachment.Table, integrationattachment.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, integrationattachment.WorkflowTable, integrationattachment.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(ia.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IntegrationAttachmentClient) Hooks() []Hook {
	return c.hooks.IntegrationAttachment
}

// Interceptors returns the client interceptors.
func (c *IntegrationAttachmentClient) Interceptors() []Interceptor {
	return c.inters.IntegrationAttachment
}

func (c *IntegrationAttachmentClient) mutate(ctx context.Context, m *IntegrationAttachmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntegrationAttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntegrationAttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntegrationAttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntegrationAttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IntegrationAttachment mutation op: %q", m.Op())
	}
}

// MembershipClient is a client for the Membership schema.
type MembershipClient struct {
	config
}

// NewMembershipClient returns a client for the Membership from the given config.
func NewMembershipClient(c config) *MembershipClient {
	return &MembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membership.Hooks(f(g(h())))`.
func (c *MembershipClient) Use(hooks ...Hook) {
	c.hooks.Membership = append(c.hooks.Membership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membership.Intercept(f(g(h())))`.
func (c *MembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.Membership = append(c.inters.Membership, interceptors...)
}

// Create returns a builder for creating a Membership entity.
func (c *MembershipClient) Create() *MembershipCreate {
	mutation := newMembershipMutation(c.config, OpCreate)
	return &MembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Membership entities.
func (c *MembershipClient) CreateBulk(builders ...*MembershipCreate) *MembershipCreateBulk {
	return &MembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Membership.
func (c *MembershipClient) Update() *MembershipUpdate {
	mutation := newMembershipMutation(c.config, OpUpdate)
	return &MembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MembershipClient) UpdateOne(m *Membership) *MembershipUpdateOne {
	mutation := newMembershipMutation(c.config, OpUpdateOne, withMembership(m))
	return &MembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MembershipClient) UpdateOneID(id uuid.UUID) *MembershipUpdateOne {
	mutation := newMembershipMutation(c.config, OpUpdateOne, withMembershipID(id))
	return &MembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Membership.
func (c *MembershipClient) Delete() *MembershipDelete {
	mutation := newMembershipMutation(c.config, OpDelete)
	return &MembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MembershipClient) DeleteOne(m *Membership) *MembershipDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MembershipClient) DeleteOneID(id uuid.UUID) *MembershipDeleteOne {
	builder := c.Delete().Where(membership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MembershipDeleteOne{builder}
}

// Query returns a query builder for Membership.
func (c *MembershipClient) Query() *MembershipQuery {
	return &MembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a Membership entity by its id.
func (c *MembershipClient) Get(ctx context.Context, id uuid.UUID) (*Membership, error) {
	return c.Query().Where(membership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MembershipClient) GetX(ctx context.Context, id uuid.UUID) *Membership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a Membership.
func (c *MembershipClient) QueryOrganization(m *Membership) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membership.Table, membership.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membership.OrganizationTable, membership.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Membership.
func (c *MembershipClient) QueryUser(m *Membership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membership.Table, membership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membership.UserTable, membership.UserColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MembershipClient) Hooks() []Hook {
	return c.hooks.Membership
}

// Interceptors returns the client interceptors.
func (c *MembershipClient) Interceptors() []Interceptor {
	return c.inters.Membership
}

func (c *MembershipClient) mutate(ctx context.Context, m *MembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Membership mutation op: %q", m.Op())
	}
}

// OrgInvitationClient is a client for the OrgInvitation schema.
type OrgInvitationClient struct {
	config
}

// NewOrgInvitationClient returns a client for the OrgInvitation from the given config.
func NewOrgInvitationClient(c config) *OrgInvitationClient {
	return &OrgInvitationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orginvitation.Hooks(f(g(h())))`.
func (c *OrgInvitationClient) Use(hooks ...Hook) {
	c.hooks.OrgInvitation = append(c.hooks.OrgInvitation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orginvitation.Intercept(f(g(h())))`.
func (c *OrgInvitationClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgInvitation = append(c.inters.OrgInvitation, interceptors...)
}

// Create returns a builder for creating a OrgInvitation entity.
func (c *OrgInvitationClient) Create() *OrgInvitationCreate {
	mutation := newOrgInvitationMutation(c.config, OpCreate)
	return &OrgInvitationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgInvitation entities.
func (c *OrgInvitationClient) CreateBulk(builders ...*OrgInvitationCreate) *OrgInvitationCreateBulk {
	return &OrgInvitationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgInvitation.
func (c *OrgInvitationClient) Update() *OrgInvitationUpdate {
	mutation := newOrgInvitationMutation(c.config, OpUpdate)
	return &OrgInvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgInvitationClient) UpdateOne(oi *OrgInvitation) *OrgInvitationUpdateOne {
	mutation := newOrgInvitationMutation(c.config, OpUpdateOne, withOrgInvitation(oi))
	return &OrgInvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgInvitationClient) UpdateOneID(id uuid.UUID) *OrgInvitationUpdateOne {
	mutation := newOrgInvitationMutation(c.config, OpUpdateOne, withOrgInvitationID(id))
	return &OrgInvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgInvitation.
func (c *OrgInvitationClient) Delete() *OrgInvitationDelete {
	mutation := newOrgInvitationMutation(c.config, OpDelete)
	return &OrgInvitationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgInvitationClient) DeleteOne(oi *OrgInvitation) *OrgInvitationDeleteOne {
	return c.DeleteOneID(oi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgInvitationClient) DeleteOneID(id uuid.UUID) *OrgInvitationDeleteOne {
	builder := c.Delete().Where(orginvitation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgInvitationDeleteOne{builder}
}

// Query returns a query builder for OrgInvitation.
func (c *OrgInvitationClient) Query() *OrgInvitationQuery {
	return &OrgInvitationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgInvitation},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgInvitation entity by its id.
func (c *OrgInvitationClient) Get(ctx context.Context, id uuid.UUID) (*OrgInvitation, error) {
	return c.Query().Where(orginvitation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgInvitationClient) GetX(ctx context.Context, id uuid.UUID) *OrgInvitation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a OrgInvitation.
func (c *OrgInvitationClient) QueryOrganization(oi *OrgInvitation) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orginvitation.Table, orginvitation.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orginvitation.OrganizationTable, orginvitation.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySender queries the sender edge of a OrgInvitation.
func (c *OrgInvitationClient) QuerySender(oi *OrgInvitation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orginvitation.Table, orginvitation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orginvitation.SenderTable, orginvitation.SenderColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrgInvitationClient) Hooks() []Hook {
	return c.hooks.OrgInvitation
}

// Interceptors returns the client interceptors.
func (c *OrgInvitationClient) Interceptors() []Interceptor {
	return c.inters.OrgInvitation
}

func (c *OrgInvitationClient) mutate(ctx context.Context, m *OrgInvitationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgInvitationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgInvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgInvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgInvitationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrgInvitation mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(o *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(o))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id uuid.UUID) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(o *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id uuid.UUID) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id uuid.UUID) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id uuid.UUID) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMemberships queries the memberships edge of a Organization.
func (c *OrganizationClient) QueryMemberships(o *Organization) *MembershipQuery {
	query := (&MembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(membership.Table, membership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.MembershipsTable, organization.MembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowContracts queries the workflow_contracts edge of a Organization.
func (c *OrganizationClient) QueryWorkflowContracts(o *Organization) *WorkflowContractQuery {
	query := (&WorkflowContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(workflowcontract.Table, workflowcontract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.WorkflowContractsTable, organization.WorkflowContractsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflows queries the workflows edge of a Organization.
func (c *OrganizationClient) QueryWorkflows(o *Organization) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.WorkflowsTable, organization.WorkflowsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCasBackends queries the cas_backends edge of a Organization.
func (c *OrganizationClient) QueryCasBackends(o *Organization) *CASBackendQuery {
	query := (&CASBackendClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(casbackend.Table, casbackend.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.CasBackendsTable, organization.CasBackendsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Organization.
func (c *OrganizationClient) QueryIntegrations(o *Organization) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.IntegrationsTable, organization.IntegrationsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	return c.hooks.Organization
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	return c.inters.Organization
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// RobotAccountClient is a client for the RobotAccount schema.
type RobotAccountClient struct {
	config
}

// NewRobotAccountClient returns a client for the RobotAccount from the given config.
func NewRobotAccountClient(c config) *RobotAccountClient {
	return &RobotAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `robotaccount.Hooks(f(g(h())))`.
func (c *RobotAccountClient) Use(hooks ...Hook) {
	c.hooks.RobotAccount = append(c.hooks.RobotAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `robotaccount.Intercept(f(g(h())))`.
func (c *RobotAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.RobotAccount = append(c.inters.RobotAccount, interceptors...)
}

// Create returns a builder for creating a RobotAccount entity.
func (c *RobotAccountClient) Create() *RobotAccountCreate {
	mutation := newRobotAccountMutation(c.config, OpCreate)
	return &RobotAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RobotAccount entities.
func (c *RobotAccountClient) CreateBulk(builders ...*RobotAccountCreate) *RobotAccountCreateBulk {
	return &RobotAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RobotAccount.
func (c *RobotAccountClient) Update() *RobotAccountUpdate {
	mutation := newRobotAccountMutation(c.config, OpUpdate)
	return &RobotAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RobotAccountClient) UpdateOne(ra *RobotAccount) *RobotAccountUpdateOne {
	mutation := newRobotAccountMutation(c.config, OpUpdateOne, withRobotAccount(ra))
	return &RobotAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RobotAccountClient) UpdateOneID(id uuid.UUID) *RobotAccountUpdateOne {
	mutation := newRobotAccountMutation(c.config, OpUpdateOne, withRobotAccountID(id))
	return &RobotAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RobotAccount.
func (c *RobotAccountClient) Delete() *RobotAccountDelete {
	mutation := newRobotAccountMutation(c.config, OpDelete)
	return &RobotAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RobotAccountClient) DeleteOne(ra *RobotAccount) *RobotAccountDeleteOne {
	return c.DeleteOneID(ra.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RobotAccountClient) DeleteOneID(id uuid.UUID) *RobotAccountDeleteOne {
	builder := c.Delete().Where(robotaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RobotAccountDeleteOne{builder}
}

// Query returns a query builder for RobotAccount.
func (c *RobotAccountClient) Query() *RobotAccountQuery {
	return &RobotAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRobotAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a RobotAccount entity by its id.
func (c *RobotAccountClient) Get(ctx context.Context, id uuid.UUID) (*RobotAccount, error) {
	return c.Query().Where(robotaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RobotAccountClient) GetX(ctx context.Context, id uuid.UUID) *RobotAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a RobotAccount.
func (c *RobotAccountClient) QueryWorkflow(ra *RobotAccount) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ra.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(robotaccount.Table, robotaccount.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, robotaccount.WorkflowTable, robotaccount.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(ra.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowruns queries the workflowruns edge of a RobotAccount.
func (c *RobotAccountClient) QueryWorkflowruns(ra *RobotAccount) *WorkflowRunQuery {
	query := (&WorkflowRunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ra.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(robotaccount.Table, robotaccount.FieldID, id),
			sqlgraph.To(workflowrun.Table, workflowrun.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, robotaccount.WorkflowrunsTable, robotaccount.WorkflowrunsColumn),
		)
		fromV = sqlgraph.Neighbors(ra.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RobotAccountClient) Hooks() []Hook {
	return c.hooks.RobotAccount
}

// Interceptors returns the client interceptors.
func (c *RobotAccountClient) Interceptors() []Interceptor {
	return c.inters.RobotAccount
}

func (c *RobotAccountClient) mutate(ctx context.Context, m *RobotAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RobotAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RobotAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RobotAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RobotAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RobotAccount mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMemberships queries the memberships edge of a User.
func (c *UserClient) QueryMemberships(u *User) *MembershipQuery {
	query := (&MembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(membership.Table, membership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MembershipsTable, user.MembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// WorkflowClient is a client for the Workflow schema.
type WorkflowClient struct {
	config
}

// NewWorkflowClient returns a client for the Workflow from the given config.
func NewWorkflowClient(c config) *WorkflowClient {
	return &WorkflowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflow.Hooks(f(g(h())))`.
func (c *WorkflowClient) Use(hooks ...Hook) {
	c.hooks.Workflow = append(c.hooks.Workflow, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflow.Intercept(f(g(h())))`.
func (c *WorkflowClient) Intercept(interceptors ...Interceptor) {
	c.inters.Workflow = append(c.inters.Workflow, interceptors...)
}

// Create returns a builder for creating a Workflow entity.
func (c *WorkflowClient) Create() *WorkflowCreate {
	mutation := newWorkflowMutation(c.config, OpCreate)
	return &WorkflowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Workflow entities.
func (c *WorkflowClient) CreateBulk(builders ...*WorkflowCreate) *WorkflowCreateBulk {
	return &WorkflowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Workflow.
func (c *WorkflowClient) Update() *WorkflowUpdate {
	mutation := newWorkflowMutation(c.config, OpUpdate)
	return &WorkflowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowClient) UpdateOne(w *Workflow) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflow(w))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowClient) UpdateOneID(id uuid.UUID) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflowID(id))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Workflow.
func (c *WorkflowClient) Delete() *WorkflowDelete {
	mutation := newWorkflowMutation(c.config, OpDelete)
	return &WorkflowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowClient) DeleteOne(w *Workflow) *WorkflowDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowClient) DeleteOneID(id uuid.UUID) *WorkflowDeleteOne {
	builder := c.Delete().Where(workflow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowDeleteOne{builder}
}

// Query returns a query builder for Workflow.
func (c *WorkflowClient) Query() *WorkflowQuery {
	return &WorkflowQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflow},
		inters: c.Interceptors(),
	}
}

// Get returns a Workflow entity by its id.
func (c *WorkflowClient) Get(ctx context.Context, id uuid.UUID) (*Workflow, error) {
	return c.Query().Where(workflow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowClient) GetX(ctx context.Context, id uuid.UUID) *Workflow {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRobotaccounts queries the robotaccounts edge of a Workflow.
func (c *WorkflowClient) QueryRobotaccounts(w *Workflow) *RobotAccountQuery {
	query := (&RobotAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(robotaccount.Table, robotaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.RobotaccountsTable, workflow.RobotaccountsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowruns queries the workflowruns edge of a Workflow.
func (c *WorkflowClient) QueryWorkflowruns(w *Workflow) *WorkflowRunQuery {
	query := (&WorkflowRunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(workflowrun.Table, workflowrun.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.WorkflowrunsTable, workflow.WorkflowrunsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a Workflow.
func (c *WorkflowClient) QueryOrganization(w *Workflow) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflow.OrganizationTable, workflow.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContract queries the contract edge of a Workflow.
func (c *WorkflowClient) QueryContract(w *Workflow) *WorkflowContractQuery {
	query := (&WorkflowContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(workflowcontract.Table, workflowcontract.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, workflow.ContractTable, workflow.ContractColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrationAttachments queries the integration_attachments edge of a Workflow.
func (c *WorkflowClient) QueryIntegrationAttachments(w *Workflow) *IntegrationAttachmentQuery {
	query := (&IntegrationAttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(integrationattachment.Table, integrationattachment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, workflow.IntegrationAttachmentsTable, workflow.IntegrationAttachmentsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowClient) Hooks() []Hook {
	return c.hooks.Workflow
}

// Interceptors returns the client interceptors.
func (c *WorkflowClient) Interceptors() []Interceptor {
	return c.inters.Workflow
}

func (c *WorkflowClient) mutate(ctx context.Context, m *WorkflowMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Workflow mutation op: %q", m.Op())
	}
}

// WorkflowContractClient is a client for the WorkflowContract schema.
type WorkflowContractClient struct {
	config
}

// NewWorkflowContractClient returns a client for the WorkflowContract from the given config.
func NewWorkflowContractClient(c config) *WorkflowContractClient {
	return &WorkflowContractClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowcontract.Hooks(f(g(h())))`.
func (c *WorkflowContractClient) Use(hooks ...Hook) {
	c.hooks.WorkflowContract = append(c.hooks.WorkflowContract, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowcontract.Intercept(f(g(h())))`.
func (c *WorkflowContractClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowContract = append(c.inters.WorkflowContract, interceptors...)
}

// Create returns a builder for creating a WorkflowContract entity.
func (c *WorkflowContractClient) Create() *WorkflowContractCreate {
	mutation := newWorkflowContractMutation(c.config, OpCreate)
	return &WorkflowContractCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowContract entities.
func (c *WorkflowContractClient) CreateBulk(builders ...*WorkflowContractCreate) *WorkflowContractCreateBulk {
	return &WorkflowContractCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowContract.
func (c *WorkflowContractClient) Update() *WorkflowContractUpdate {
	mutation := newWorkflowContractMutation(c.config, OpUpdate)
	return &WorkflowContractUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowContractClient) UpdateOne(wc *WorkflowContract) *WorkflowContractUpdateOne {
	mutation := newWorkflowContractMutation(c.config, OpUpdateOne, withWorkflowContract(wc))
	return &WorkflowContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowContractClient) UpdateOneID(id uuid.UUID) *WorkflowContractUpdateOne {
	mutation := newWorkflowContractMutation(c.config, OpUpdateOne, withWorkflowContractID(id))
	return &WorkflowContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowContract.
func (c *WorkflowContractClient) Delete() *WorkflowContractDelete {
	mutation := newWorkflowContractMutation(c.config, OpDelete)
	return &WorkflowContractDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowContractClient) DeleteOne(wc *WorkflowContract) *WorkflowContractDeleteOne {
	return c.DeleteOneID(wc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowContractClient) DeleteOneID(id uuid.UUID) *WorkflowContractDeleteOne {
	builder := c.Delete().Where(workflowcontract.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowContractDeleteOne{builder}
}

// Query returns a query builder for WorkflowContract.
func (c *WorkflowContractClient) Query() *WorkflowContractQuery {
	return &WorkflowContractQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowContract},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowContract entity by its id.
func (c *WorkflowContractClient) Get(ctx context.Context, id uuid.UUID) (*WorkflowContract, error) {
	return c.Query().Where(workflowcontract.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowContractClient) GetX(ctx context.Context, id uuid.UUID) *WorkflowContract {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVersions queries the versions edge of a WorkflowContract.
func (c *WorkflowContractClient) QueryVersions(wc *WorkflowContract) *WorkflowContractVersionQuery {
	query := (&WorkflowContractVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowcontract.Table, workflowcontract.FieldID, id),
			sqlgraph.To(workflowcontractversion.Table, workflowcontractversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowcontract.VersionsTable, workflowcontract.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(wc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a WorkflowContract.
func (c *WorkflowContractClient) QueryOrganization(wc *WorkflowContract) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowcontract.Table, workflowcontract.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowcontract.OrganizationTable, workflowcontract.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(wc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflows queries the workflows edge of a WorkflowContract.
func (c *WorkflowContractClient) QueryWorkflows(wc *WorkflowContract) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowcontract.Table, workflowcontract.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, workflowcontract.WorkflowsTable, workflowcontract.WorkflowsColumn),
		)
		fromV = sqlgraph.Neighbors(wc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowContractClient) Hooks() []Hook {
	return c.hooks.WorkflowContract
}

// Interceptors returns the client interceptors.
func (c *WorkflowContractClient) Interceptors() []Interceptor {
	return c.inters.WorkflowContract
}

func (c *WorkflowContractClient) mutate(ctx context.Context, m *WorkflowContractMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowContractCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowContractUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowContractDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowContract mutation op: %q", m.Op())
	}
}

// WorkflowContractVersionClient is a client for the WorkflowContractVersion schema.
type WorkflowContractVersionClient struct {
	config
}

// NewWorkflowContractVersionClient returns a client for the WorkflowContractVersion from the given config.
func NewWorkflowContractVersionClient(c config) *WorkflowContractVersionClient {
	return &WorkflowContractVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowcontractversion.Hooks(f(g(h())))`.
func (c *WorkflowContractVersionClient) Use(hooks ...Hook) {
	c.hooks.WorkflowContractVersion = append(c.hooks.WorkflowContractVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowcontractversion.Intercept(f(g(h())))`.
func (c *WorkflowContractVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowContractVersion = append(c.inters.WorkflowContractVersion, interceptors...)
}

// Create returns a builder for creating a WorkflowContractVersion entity.
func (c *WorkflowContractVersionClient) Create() *WorkflowContractVersionCreate {
	mutation := newWorkflowContractVersionMutation(c.config, OpCreate)
	return &WorkflowContractVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowContractVersion entities.
func (c *WorkflowContractVersionClient) CreateBulk(builders ...*WorkflowContractVersionCreate) *WorkflowContractVersionCreateBulk {
	return &WorkflowContractVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowContractVersion.
func (c *WorkflowContractVersionClient) Update() *WorkflowContractVersionUpdate {
	mutation := newWorkflowContractVersionMutation(c.config, OpUpdate)
	return &WorkflowContractVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowContractVersionClient) UpdateOne(wcv *WorkflowContractVersion) *WorkflowContractVersionUpdateOne {
	mutation := newWorkflowContractVersionMutation(c.config, OpUpdateOne, withWorkflowContractVersion(wcv))
	return &WorkflowContractVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowContractVersionClient) UpdateOneID(id uuid.UUID) *WorkflowContractVersionUpdateOne {
	mutation := newWorkflowContractVersionMutation(c.config, OpUpdateOne, withWorkflowContractVersionID(id))
	return &WorkflowContractVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowContractVersion.
func (c *WorkflowContractVersionClient) Delete() *WorkflowContractVersionDelete {
	mutation := newWorkflowContractVersionMutation(c.config, OpDelete)
	return &WorkflowContractVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowContractVersionClient) DeleteOne(wcv *WorkflowContractVersion) *WorkflowContractVersionDeleteOne {
	return c.DeleteOneID(wcv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowContractVersionClient) DeleteOneID(id uuid.UUID) *WorkflowContractVersionDeleteOne {
	builder := c.Delete().Where(workflowcontractversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowContractVersionDeleteOne{builder}
}

// Query returns a query builder for WorkflowContractVersion.
func (c *WorkflowContractVersionClient) Query() *WorkflowContractVersionQuery {
	return &WorkflowContractVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowContractVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowContractVersion entity by its id.
func (c *WorkflowContractVersionClient) Get(ctx context.Context, id uuid.UUID) (*WorkflowContractVersion, error) {
	return c.Query().Where(workflowcontractversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowContractVersionClient) GetX(ctx context.Context, id uuid.UUID) *WorkflowContractVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContract queries the contract edge of a WorkflowContractVersion.
func (c *WorkflowContractVersionClient) QueryContract(wcv *WorkflowContractVersion) *WorkflowContractQuery {
	query := (&WorkflowContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wcv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowcontractversion.Table, workflowcontractversion.FieldID, id),
			sqlgraph.To(workflowcontract.Table, workflowcontract.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowcontractversion.ContractTable, workflowcontractversion.ContractColumn),
		)
		fromV = sqlgraph.Neighbors(wcv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowContractVersionClient) Hooks() []Hook {
	return c.hooks.WorkflowContractVersion
}

// Interceptors returns the client interceptors.
func (c *WorkflowContractVersionClient) Interceptors() []Interceptor {
	return c.inters.WorkflowContractVersion
}

func (c *WorkflowContractVersionClient) mutate(ctx context.Context, m *WorkflowContractVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowContractVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowContractVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowContractVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowContractVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowContractVersion mutation op: %q", m.Op())
	}
}

// WorkflowRunClient is a client for the WorkflowRun schema.
type WorkflowRunClient struct {
	config
}

// NewWorkflowRunClient returns a client for the WorkflowRun from the given config.
func NewWorkflowRunClient(c config) *WorkflowRunClient {
	return &WorkflowRunClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowrun.Hooks(f(g(h())))`.
func (c *WorkflowRunClient) Use(hooks ...Hook) {
	c.hooks.WorkflowRun = append(c.hooks.WorkflowRun, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowrun.Intercept(f(g(h())))`.
func (c *WorkflowRunClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowRun = append(c.inters.WorkflowRun, interceptors...)
}

// Create returns a builder for creating a WorkflowRun entity.
func (c *WorkflowRunClient) Create() *WorkflowRunCreate {
	mutation := newWorkflowRunMutation(c.config, OpCreate)
	return &WorkflowRunCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowRun entities.
func (c *WorkflowRunClient) CreateBulk(builders ...*WorkflowRunCreate) *WorkflowRunCreateBulk {
	return &WorkflowRunCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowRun.
func (c *WorkflowRunClient) Update() *WorkflowRunUpdate {
	mutation := newWorkflowRunMutation(c.config, OpUpdate)
	return &WorkflowRunUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowRunClient) UpdateOne(wr *WorkflowRun) *WorkflowRunUpdateOne {
	mutation := newWorkflowRunMutation(c.config, OpUpdateOne, withWorkflowRun(wr))
	return &WorkflowRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowRunClient) UpdateOneID(id uuid.UUID) *WorkflowRunUpdateOne {
	mutation := newWorkflowRunMutation(c.config, OpUpdateOne, withWorkflowRunID(id))
	return &WorkflowRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowRun.
func (c *WorkflowRunClient) Delete() *WorkflowRunDelete {
	mutation := newWorkflowRunMutation(c.config, OpDelete)
	return &WorkflowRunDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowRunClient) DeleteOne(wr *WorkflowRun) *WorkflowRunDeleteOne {
	return c.DeleteOneID(wr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowRunClient) DeleteOneID(id uuid.UUID) *WorkflowRunDeleteOne {
	builder := c.Delete().Where(workflowrun.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowRunDeleteOne{builder}
}

// Query returns a query builder for WorkflowRun.
func (c *WorkflowRunClient) Query() *WorkflowRunQuery {
	return &WorkflowRunQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowRun},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowRun entity by its id.
func (c *WorkflowRunClient) Get(ctx context.Context, id uuid.UUID) (*WorkflowRun, error) {
	return c.Query().Where(workflowrun.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowRunClient) GetX(ctx context.Context, id uuid.UUID) *WorkflowRun {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a WorkflowRun.
func (c *WorkflowRunClient) QueryWorkflow(wr *WorkflowRun) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowrun.Table, workflowrun.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowrun.WorkflowTable, workflowrun.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(wr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRobotaccount queries the robotaccount edge of a WorkflowRun.
func (c *WorkflowRunClient) QueryRobotaccount(wr *WorkflowRun) *RobotAccountQuery {
	query := (&RobotAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowrun.Table, workflowrun.FieldID, id),
			sqlgraph.To(robotaccount.Table, robotaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowrun.RobotaccountTable, workflowrun.RobotaccountColumn),
		)
		fromV = sqlgraph.Neighbors(wr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContractVersion queries the contract_version edge of a WorkflowRun.
func (c *WorkflowRunClient) QueryContractVersion(wr *WorkflowRun) *WorkflowContractVersionQuery {
	query := (&WorkflowContractVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowrun.Table, workflowrun.FieldID, id),
			sqlgraph.To(workflowcontractversion.Table, workflowcontractversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, workflowrun.ContractVersionTable, workflowrun.ContractVersionColumn),
		)
		fromV = sqlgraph.Neighbors(wr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCasBackends queries the cas_backends edge of a WorkflowRun.
func (c *WorkflowRunClient) QueryCasBackends(wr *WorkflowRun) *CASBackendQuery {
	query := (&CASBackendClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowrun.Table, workflowrun.FieldID, id),
			sqlgraph.To(casbackend.Table, casbackend.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, workflowrun.CasBackendsTable, workflowrun.CasBackendsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(wr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowRunClient) Hooks() []Hook {
	return c.hooks.WorkflowRun
}

// Interceptors returns the client interceptors.
func (c *WorkflowRunClient) Interceptors() []Interceptor {
	return c.inters.WorkflowRun
}

func (c *WorkflowRunClient) mutate(ctx context.Context, m *WorkflowRunMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowRunCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowRunUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowRunDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowRun mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		CASBackend, CASMapping, Integration, IntegrationAttachment, Membership,
		OrgInvitation, Organization, RobotAccount, User, Workflow, WorkflowContract,
		WorkflowContractVersion, WorkflowRun []ent.Hook
	}
	inters struct {
		CASBackend, CASMapping, Integration, IntegrationAttachment, Membership,
		OrgInvitation, Organization, RobotAccount, User, Workflow, WorkflowContract,
		WorkflowContractVersion, WorkflowRun []ent.Interceptor
	}
)
